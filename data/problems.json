[
    {
        "id": "two-sum",
        "title": "001. Two Sum",
        "difficulty": "Easy",
        "description": "Dada una matriz de enteros `nums` y un entero `target`, devuelve los índices de los dos números tales que sumen `target`. Se asume que existe exactamente una solución y no puedes usar el mismo elemento dos veces.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Fuerza Bruta (N^2)",
                "explanation": "Esta es la aproximación más directa. Consiste en iterar sobre cada elemento de la matriz y, para cada uno, iterar nuevamente sobre el resto de los elementos para ver si la suma de ambos es igual al `target`. Es ineficiente para arrays grandes, ya que requiere dos bucles anidados.",
                "code_snippet": "function twoSum(nums, target) {\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = i + 1; j < nums.length; j++) {\n            if (nums[i] + nums[j] === target) {\n                return [i, j];\n            }\n        }\n    }\n    return [];\n}",
                "complexity": "Time: O(N^2), Space: O(1)",
                "example": {
                    "input": "nums = [2, 7, 11, 15], target = 9",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Probando nums[0] = 2 + nums[1] = 7",
                            "variables": {
                                "i": 0,
                                "j": 1,
                                "nums_i": 2,
                                "nums_j": 7,
                                "sum": 9
                            },
                            "code_line": "if (nums[0] + nums[1] === 9)",
                            "output": "✓ Encontrado! [0, 1]"
                        }
                    ],
                    "final_output": "[0, 1]"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Hash Map (Optimización O(N))",
                "explanation": "La clave para optimizar a O(N) es evitar el segundo bucle. En su lugar, calculamos el 'complemento' (`target - nums[i]`) y verificamos si ese complemento ya ha sido visto. Usamos un mapa (o hash table) para almacenar los números vistos y sus índices, lo que permite búsquedas en tiempo promedio O(1).",
                "code_snippet": "function twoSum(nums, target) {\n    const map = new Map();\n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (map.has(complement)) {\n            // El complemento ya fue visto, devolvemos su índice y el índice actual (i)\n            return [map.get(complement), i];\n        }\n        // Si no se encuentra, almacenamos el número actual y su índice para futuras búsquedas\n        map.set(nums[i], i);\n    }\n    return [];\n}",
                "complexity": "Time: O(N), Space: O(N)",
                "example": {
                    "input": "nums = [2, 7, 11, 15], target = 9",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Revisando nums[0] = 2, buscando complemento 7",
                            "variables": {
                                "i": 0,
                                "nums_i": 2,
                                "complement": 7,
                                "map": {},
                                "has_complement": false
                            },
                            "code_line": "if (map.has(7))",
                            "output": "Agregando 2 al mapa"
                        },
                        {
                            "iteration": 2,
                            "description": "Revisando nums[1] = 7, buscando complemento 2",
                            "variables": {
                                "i": 1,
                                "nums_i": 7,
                                "complement": 2,
                                "map": {
                                    "2": 0
                                },
                                "has_complement": true
                            },
                            "code_line": "if (map.has(2))",
                            "output": "✓ Encontrado! [0, 1]"
                        }
                    ],
                    "final_output": "[0, 1]"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Recursión con Memoización",
                "explanation": "Una aproximación recursiva que divide el problema en subproblemas más pequeños. Para cada elemento, intentamos encontrar un complemento recursivamente en el resto del array. Usamos memoización para evitar cálculos repetidos, mejorando el rendimiento sobre la recursión pura.",
                "code_snippet": "function twoSum(nums, target, start = 0, memo = new Map()) {\n    if (start >= nums.length) return [];\n    \n    const key = `${start}-${target}`;\n    if (memo.has(key)) return memo.get(key);\n    \n    for (let i = start + 1; i < nums.length; i++) {\n        if (nums[start] + nums[i] === target) {\n            const result = [start, i];\n            memo.set(key, result);\n            return result;\n        }\n    }\n    \n    const result = twoSum(nums, target, start + 1, memo);\n    memo.set(key, result);\n    return result;\n}",
                "complexity": "Time: O(N^2) en peor caso, mejor con memoización, Space: O(N) por recursión y memo",
                "example": {
                    "input": "[2, 7, 11, 15], 9",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[2, 7, 11, 15], 9"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[2, 7, 11, 15], 9",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[2, 7, 11, 15], 9",
                                "result": "[0, 1]"
                            },
                            "code_line": "return resultado",
                            "output": "[0, 1]"
                        }
                    ],
                    "final_output": "[0, 1]"
                }
            }
        ]
    },
    {
        "id": "add-two-numbers",
        "title": "002. Add Two Numbers",
        "difficulty": "Medium",
        "description": "Se te dan dos listas enlazadas no vacías que representan dos números enteros no negativos. Los dígitos se almacenan en orden inverso, y cada uno de sus nodos contiene un solo dígito. Suma los dos números y devuelve la suma como una lista enlazada.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Iteración con 'Carry'",
                "explanation": "Simulamos la suma que haríamos manualmente, dígito por dígito, empezando por el nodo de la cabeza (unidades). Usamos una variable `carry` para rastrear si la suma de los dígitos excede 9 (llevando 1 a la siguiente posición). El proceso continúa hasta que ambas listas se agotan y no queda `carry`.",
                "code_snippet": "function addTwoNumbers(l1, l2) {\n    let dummyHead = new ListNode(0);\n    let current = dummyHead;\n    let carry = 0;\n    \n    while (l1 !== null || l2 !== null || carry !== 0) {\n        const val1 = l1 ? l1.val : 0;\n        const val2 = l2 ? l2.val : 0;\n        \n        const sum = val1 + val2 + carry;\n        carry = Math.floor(sum / 10); // Nuevo acarreo (0 o 1)\n        const digit = sum % 10;        // El dígito actual\n        \n        current.next = new ListNode(digit);\n        current = current.next;\n        \n        if (l1) l1 = l1.next;\n        if (l2) l2 = l2.next;\n    }\n    \n    return dummyHead.next;\n}",
                "complexity": "Time: O(max(L1, L2)), Space: O(max(L1, L2))",
                "example": {
                    "input": "(2 -> 4 -> 3) + (5 -> 6 -> 4)",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "(2 -> 4 -> 3) + (5 -> 6 -> 4)"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "(2 -> 4 -> 3) + (5 -> 6 -> 4)",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "(2 -> 4 -> 3) + (5 -> 6 -> 4)",
                                "result": "7 -> 0 -> 8"
                            },
                            "code_line": "return resultado",
                            "output": "7 -> 0 -> 8"
                        }
                    ],
                    "final_output": "7 -> 0 -> 8"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Recursiva",
                "explanation": "Una solución recursiva elegante que procesa las listas nodo por nodo. La función recursiva maneja un nodo de cada lista a la vez, calcula la suma y el carry, y luego procesa recursivamente el resto de las listas. El caso base ocurre cuando ambas listas son nulas y no hay carry.",
                "code_snippet": "function addTwoNumbers(l1, l2, carry = 0) {\n    if (!l1 && !l2 && carry === 0) return null;\n    \n    const val1 = l1 ? l1.val : 0;\n    const val2 = l2 ? l2.val : 0;\n    const sum = val1 + val2 + carry;\n    \n    const result = new ListNode(sum % 10);\n    const newCarry = Math.floor(sum / 10);\n    \n    result.next = addTwoNumbers(\n        l1 ? l1.next : null,\n        l2 ? l2.next : null,\n        newCarry\n    );\n    \n    return result;\n}",
                "complexity": "Time: O(max(L1, L2)), Space: O(max(L1, L2)) por la pila de recursión",
                "example": {
                    "input": "l1 = (2 -> 4 -> 3), l2 = (5 -> 6 -> 4)",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Procesando nodos: 2 + 5 + 0 = 7, carry = 0",
                            "variables": {
                                "val1": 2,
                                "val2": 5,
                                "carry": 0,
                                "sum": 7,
                                "digit": 7
                            },
                            "code_line": "sum = val1 + val2 + carry"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando nodos: 4 + 6 + 0 = 10, carry = 1",
                            "variables": {
                                "val1": 4,
                                "val2": 6,
                                "carry": 0,
                                "sum": 10,
                                "digit": 0
                            },
                            "code_line": "sum = val1 + val2 + carry"
                        },
                        {
                            "iteration": 3,
                            "description": "Procesando nodos: 3 + 4 + 1 = 8, carry = 0",
                            "variables": {
                                "val1": 3,
                                "val2": 4,
                                "carry": 1,
                                "sum": 8,
                                "digit": 8
                            },
                            "code_line": "sum = val1 + val2 + carry"
                        }
                    ],
                    "final_output": "7 -> 0 -> 8"
                }
            },
            {
                "id": 4,
                "title": "Solución 3: Recursiva",
                "explanation": "Una solución recursiva elegante que procesa las listas nodo por nodo. La función recursiva maneja un nodo de cada lista a la vez, calcula la suma y el carry, y luego procesa recursivamente el resto de las listas. El caso base ocurre cuando ambas listas son nulas y no hay carry.",
                "code_snippet": "function addTwoNumbers(l1, l2, carry = 0) {\n    if (!l1 && !l2 && carry === 0) return null;\n    \n    const val1 = l1 ? l1.val : 0;\n    const val2 = l2 ? l2.val : 0;\n    const sum = val1 + val2 + carry;\n    \n    const result = new ListNode(sum % 10);\n    const newCarry = Math.floor(sum / 10);\n    \n    result.next = addTwoNumbers(\n        l1 ? l1.next : null,\n        l2 ? l2.next : null,\n        newCarry\n    );\n    \n    return result;\n}",
                "complexity": "Time: O(max(L1, L2)), Space: O(max(L1, L2)) por la pila de recursión",
                "example": {
                    "input": "l1 = (2 -> 4 -> 3), l2 = (5 -> 6 -> 4)",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Procesando nodos: 2 + 5 + 0 = 7, carry = 0",
                            "variables": {
                                "val1": 2,
                                "val2": 5,
                                "carry": 0,
                                "sum": 7,
                                "digit": 7
                            },
                            "code_line": "sum = val1 + val2 + carry"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando nodos: 4 + 6 + 0 = 10, carry = 1",
                            "variables": {
                                "val1": 4,
                                "val2": 6,
                                "carry": 0,
                                "sum": 10,
                                "digit": 0
                            },
                            "code_line": "sum = val1 + val2 + carry"
                        },
                        {
                            "iteration": 3,
                            "description": "Procesando nodos: 3 + 4 + 1 = 8, carry = 0",
                            "variables": {
                                "val1": 3,
                                "val2": 4,
                                "carry": 1,
                                "sum": 8,
                                "digit": 8
                            },
                            "code_line": "sum = val1 + val2 + carry"
                        }
                    ],
                    "final_output": "7 -> 0 -> 8"
                }
            }
        ]
    },
    {
        "id": "longest-substring-without-repeating-characters",
        "title": "003. Longest Substring Without Repeating Characters",
        "difficulty": "Medium",
        "description": "Dada una cadena `s`, encuentra la longitud de la subcadena más larga sin caracteres repetidos.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Sliding Window (Ventana Deslizante)",
                "explanation": "Usamos una 'ventana deslizante' definida por dos punteros, `left` y `right`, para mantener la subcadena actual sin repeticiones. Utilizamos un conjunto (`Set` o `Map`) para rastrear los caracteres dentro de la ventana. Si encontramos un duplicado en `s[right]`, movemos el puntero `left` hacia la derecha, eliminando caracteres del conjunto, hasta que el duplicado se elimine de la ventana. En cada paso, actualizamos la longitud máxima.",
                "code_snippet": "function lengthOfLongestSubstring(s) {\n    let set = new Set();\n    let left = 0;\n    let maxLength = 0;\n    \n    for (let right = 0; right < s.length; right++) {\n        // Si el caracter ya existe en el set, encoge la ventana desde la izquierda\n        while (set.has(s[right])) {\n            set.delete(s[left]);\n            left++;\n        }\n        // Agrega el nuevo caracter y expande la ventana hacia la derecha\n        set.add(s[right]);\n        // Actualiza la longitud máxima de la ventana (right - left + 1)\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    return maxLength;\n}",
                "complexity": "Time: O(N), Space: O(min(N, AlphabetSize))",
                "example": {
                    "input": "\"abcabcbb\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "\"abcabcbb\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "\"abcabcbb\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "\"abcabcbb\"",
                                "result": "3 (Subcadena: \"abc\")"
                            },
                            "code_line": "return resultado",
                            "output": "3 (Subcadena: \"abc\")"
                        }
                    ],
                    "final_output": "3 (Subcadena: \"abc\")"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Array (ASCII)",
                "explanation": "Similar a la solución con Set, pero usa un array de tamaño 128 (para caracteres ASCII estándar) en lugar de un Set. El índice del array representa el código ASCII del carácter, y el valor almacenado es la última posición donde se vio ese carácter. Esto permite determinar rápidamente si un carácter es nuevo o se repitió.",
                "code_snippet": "function lengthOfLongestSubstring(s) {\n    const charIndex = new Array(128).fill(-1);\n    let left = 0;\n    let maxLength = 0;\n    \n    for (let right = 0; right < s.length; right++) {\n        const charCode = s.charCodeAt(right);\n        \n        // Si el caracter ya fue visto y está dentro de la ventana actual\n        if (charIndex[charCode] >= left) {\n            left = charIndex[charCode] + 1;\n        }\n        \n        charIndex[charCode] = right;\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    \n    return maxLength;\n}",
                "complexity": "Time: O(N), Space: O(1) [array de tamaño fijo 128]",
                "example": {
                    "input": "s = \"abcabcbb\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "right=0, char='a', left=0, ventana=\"a\"",
                            "variables": {
                                "right": 0,
                                "left": 0,
                                "char": "a",
                                "maxLength": 1
                            },
                            "code_line": "Agregando 'a'"
                        },
                        {
                            "iteration": 2,
                            "description": "right=1, char='b', left=0, ventana=\"ab\"",
                            "variables": {
                                "right": 1,
                                "left": 0,
                                "char": "b",
                                "maxLength": 2
                            },
                            "code_line": "Agregando 'b'"
                        },
                        {
                            "iteration": 3,
                            "description": "right=2, char='c', left=0, ventana=\"abc\"",
                            "variables": {
                                "right": 2,
                                "left": 0,
                                "char": "c",
                                "maxLength": 3
                            },
                            "code_line": "Agregando 'c'"
                        },
                        {
                            "iteration": 4,
                            "description": "right=3, char='a' (repetido), moviendo left a 1",
                            "variables": {
                                "right": 3,
                                "left": 1,
                                "char": "a",
                                "maxLength": 3
                            },
                            "code_line": "Duplicado encontrado, ajustando ventana"
                        }
                    ],
                    "final_output": "3 (Subcadena: \"abc\")"
                }
            },
            {
                "id": 4,
                "title": "Solución 3: Optimizada con Array (ASCII)",
                "explanation": "Similar a la solución con Set, pero usa un array de tamaño 128 (para caracteres ASCII estándar) en lugar de un Set. El índice del array representa el código ASCII del carácter, y el valor almacenado es la última posición donde se vio ese carácter. Esto permite determinar rápidamente si un carácter es nuevo o se repitió.",
                "code_snippet": "function lengthOfLongestSubstring(s) {\n    const charIndex = new Array(128).fill(-1);\n    let left = 0;\n    let maxLength = 0;\n    \n    for (let right = 0; right < s.length; right++) {\n        const charCode = s.charCodeAt(right);\n        \n        // Si el caracter ya fue visto y está dentro de la ventana actual\n        if (charIndex[charCode] >= left) {\n            left = charIndex[charCode] + 1;\n        }\n        \n        charIndex[charCode] = right;\n        maxLength = Math.max(maxLength, right - left + 1);\n    }\n    \n    return maxLength;\n}",
                "complexity": "Time: O(N), Space: O(1) [array de tamaño fijo 128]",
                "example": {
                    "input": "s = \"abcabcbb\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "right=0, char='a', left=0, ventana=\"a\"",
                            "variables": {
                                "right": 0,
                                "left": 0,
                                "char": "a",
                                "maxLength": 1
                            },
                            "code_line": "Agregando 'a'"
                        },
                        {
                            "iteration": 2,
                            "description": "right=1, char='b', left=0, ventana=\"ab\"",
                            "variables": {
                                "right": 1,
                                "left": 0,
                                "char": "b",
                                "maxLength": 2
                            },
                            "code_line": "Agregando 'b'"
                        },
                        {
                            "iteration": 3,
                            "description": "right=2, char='c', left=0, ventana=\"abc\"",
                            "variables": {
                                "right": 2,
                                "left": 0,
                                "char": "c",
                                "maxLength": 3
                            },
                            "code_line": "Agregando 'c'"
                        },
                        {
                            "iteration": 4,
                            "description": "right=3, char='a' (repetido), moviendo left a 1",
                            "variables": {
                                "right": 3,
                                "left": 1,
                                "char": "a",
                                "maxLength": 3
                            },
                            "code_line": "Duplicado encontrado, ajustando ventana"
                        }
                    ],
                    "final_output": "3 (Subcadena: \"abc\")"
                }
            }
        ]
    },
    {
        "id": "valid-parentheses",
        "title": "020. Valid Parentheses",
        "difficulty": "Easy",
        "description": "Dada una cadena que contiene solo los caracteres '(', ')', '{', '}', '[' y ']', determina si la cadena de entrada es válida. Una cadena es válida si los paréntesis de apertura deben cerrarse con el mismo tipo de paréntesis y en el orden correcto.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Stack (Pila)",
                "explanation": "Este problema es un caso clásico de uso de pilas. Cuando encontramos un paréntesis de apertura ('(', '{', '['), lo empujamos a la pila. Cuando encontramos uno de cierre, verificamos si la pila está vacía o si el elemento superior de la pila es su par de apertura correspondiente. Si no coinciden, la cadena es inválida. Al finalizar, la pila debe estar vacía para que todos los abridores hayan sido cerrados.",
                "code_snippet": "function isValid(s) {\n    const stack = [];\n    const map = {\n        ')': '(',\n        '}': '{',\n        ']': '['\n    };\n    for (const char of s) {\n        // Si es un caracter de cierre\n        if (char in map) {\n            // 1. La pila está vacía O 2. El último elemento no es el par coincidente\n            if (stack.length === 0 || stack.pop() !== map[char]) {\n                return false;\n            }\n        } else {\n            // Si es un caracter de apertura, lo agregamos a la pila\n            stack.push(char);\n        }\n    }\n    // Si la pila está vacía, todos los paréntesis se cerraron correctamente\n    return stack.length === 0;\n}",
                "complexity": "Time: O(N), Space: O(N)",
                "example": {
                    "input": "\"([{}])\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "\"([{}])\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "\"([{}])\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "\"([{}])\"",
                                "result": "true"
                            },
                            "code_line": "return resultado",
                            "output": "true"
                        }
                    ],
                    "final_output": "true"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function isValid(s) {\n    const stack = [];\n    const map = {\n        ')': '(',\n        '}': '{',\n        ']': '['\n    };\n    for (const char of s) {\n        // Si es un caracter de cierre\n        if (char in map) {\n            // 1. La pila está vacía O 2. El último elemento no es el par coincidente\n            if (stack.length === 0 || stack.pop() !== map[char]) {\n                return false;\n            }\n        } else {\n            // Si es un caracter de apertura, lo agregamos a la pila\n            stack.push(char);\n        }\n    }\n    // Si la pila está vacía, todos los paréntesis se cerraron correctamente\n    return stack.length === 0;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(N)",
                "example": {
                    "input": "\"([{}])\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "\"([{}])\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "\"([{}])\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "\"([{}])\"",
                                "result": "true"
                            },
                            "code_line": "return resultado",
                            "output": "true"
                        }
                    ],
                    "final_output": "true"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function isValid(s) {\n    const stack = [];\n    const map = {\n        ')': '(',\n        '}': '{',\n        ']': '['\n    };\n    for (const char of s) {\n        // Si es un caracter de cierre\n        if (char in map) {\n            // 1. La pila está vacía O 2. El último elemento no es el par coincidente\n            if (stack.length === 0 || stack.pop() !== map[char]) {\n                return false;\n            }\n        } else {\n            // Si es un caracter de apertura, lo agregamos a la pila\n            stack.push(char);\n        }\n    }\n    // Si la pila está vacía, todos los paréntesis se cerraron correctamente\n    return stack.length === 0;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(N)",
                "example": {
                    "input": "\"([{}])\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "\"([{}])\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "\"([{}])\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "\"([{}])\"",
                                "result": "true"
                            },
                            "code_line": "return resultado",
                            "output": "true"
                        }
                    ],
                    "final_output": "true"
                }
            }
        ]
    },
    {
        "id": "merge-two-sorted-lists",
        "title": "021. Merge Two Sorted Lists",
        "difficulty": "Easy",
        "description": "Combina dos listas enlazadas ordenadas en una sola lista enlazada ordenada. La nueva lista debería crearse empalmando los nodos de las dos listas originales.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Iterativa con Nodo Dummy",
                "explanation": "Usamos un 'nodo dummy' como punto de partida para la nueva lista combinada, lo que simplifica la lógica al no tener que manejar un caso especial para la cabeza. Iteramos mientras ambas listas tengan nodos, comparando los valores de los nodos actuales (`l1.val` vs `l2.val`) y adjuntando el menor al final de la lista combinada, avanzando el puntero de esa lista. Una vez que una lista se vacía, adjuntamos los nodos restantes de la otra lista.",
                "code_snippet": "function mergeTwoLists(l1, l2) {\n    const dummy = new ListNode(0);\n    let current = dummy;\n    \n    while (l1 !== null && l2 !== null) {\n        if (l1.val <= l2.val) {\n            current.next = l1;\n            l1 = l1.next;\n        } else {\n            current.next = l2;\n            l2 = l2.next;\n        }\n        current = current.next;\n    }\n    \n    // Adjuntar los nodos restantes (solo uno de estos será no-nulo)\n    if (l1 !== null) {\n        current.next = l1;\n    } else if (l2 !== null) {\n        current.next = l2;\n    }\n    \n    return dummy.next;\n}",
                "complexity": "Time: O(L1 + L2), Space: O(1) [sin contar la salida]",
                "example": {
                    "input": "l1 = [1,2,4], l2 = [1,3,4]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "l1 = [1,2,4], l2 = [1,3,4]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "l1 = [1,2,4], l2 = [1,3,4]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "l1 = [1,2,4], l2 = [1,3,4]",
                                "result": "[1,1,2,3,4,4]"
                            },
                            "code_line": "return resultado",
                            "output": "[1,1,2,3,4,4]"
                        }
                    ],
                    "final_output": "[1,1,2,3,4,4]"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Fuerza Bruta (Alternativa)",
                "explanation": "Una aproximación de fuerza bruta que explora todas las posibles combinaciones. Aunque menos eficiente en términos de complejidad temporal, es más fácil de entender y puede ser útil para problemas pequeños o como punto de partida para optimizaciones.",
                "code_snippet": "function mergeTwoLists(l1, l2) {\n    const dummy = new ListNode(0);\n    let current = dummy;\n    \n    while (l1 !== null && l2 !== null) {\n        if (l1.val <= l2.val) {\n            current.next = l1;\n            l1 = l1.next;\n        } else {\n            current.next = l2;\n            l2 = l2.next;\n        }\n        current = current.next;\n    }\n    \n    // Adjuntar los nodos restantes (solo uno de estos será no-nulo)\n    if (l1 !== null) {\n        current.next = l1;\n    } else if (l2 !== null) {\n        current.next = l2;\n    }\n    \n    return dummy.next;\n} // Variación alternativa",
                "complexity": "Time: O(L1 + L2), Space: O(1) [sin contar la salida]",
                "example": {
                    "input": "l1 = [1,2,4], l2 = [1,3,4]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "l1 = [1,2,4], l2 = [1,3,4]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "l1 = [1,2,4], l2 = [1,3,4]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "l1 = [1,2,4], l2 = [1,3,4]",
                                "result": "[1,1,2,3,4,4]"
                            },
                            "code_line": "return resultado",
                            "output": "[1,1,2,3,4,4]"
                        }
                    ],
                    "final_output": "[1,1,2,3,4,4]"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Recursiva con Memoización",
                "explanation": "Una solución recursiva que divide el problema en subproblemas más pequeños. Usa memoización para almacenar los resultados de subproblemas ya calculados, evitando cálculos repetidos y mejorando significativamente el rendimiento sobre la recursión pura.",
                "code_snippet": "function mergeTwoLists(l1, l2) {\n    const dummy = new ListNode(0);\n    let current = dummy;\n    \n    while (l1 !== null && l2 !== null) {\n        if (l1.val <= l2.val) {\n            current.next = l1;\n            l1 = l1.next;\n        } else {\n            current.next = l2;\n            l2 = l2.next;\n        }\n        current = current.next;\n    }\n    \n    // Adjuntar los nodos restantes (solo uno de estos será no-nulo)\n    if (l1 !== null) {\n        current.next = l1;\n    } else if (l2 !== null) {\n        current.next = l2;\n    }\n    \n    return dummy.next;\n} // Variación alternativa",
                "complexity": "Time: O(L1 + L2), Space: O(1) [sin contar la salida]",
                "example": {
                    "input": "l1 = [1,2,4], l2 = [1,3,4]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "l1 = [1,2,4], l2 = [1,3,4]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "l1 = [1,2,4], l2 = [1,3,4]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "l1 = [1,2,4], l2 = [1,3,4]",
                                "result": "[1,1,2,3,4,4]"
                            },
                            "code_line": "return resultado",
                            "output": "[1,1,2,3,4,4]"
                        }
                    ],
                    "final_output": "[1,1,2,3,4,4]"
                }
            }
        ]
    },
    {
        "id": "maximum-subarray",
        "title": "053. Maximum Subarray",
        "difficulty": "Easy",
        "description": "Dado un array de enteros `nums`, encuentra la submatriz contigua que tiene la suma más grande y devuelve su suma.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Algoritmo de Kadane",
                "explanation": "El algoritmo de Kadane es una técnica de programación dinámica eficiente. Mantiene dos variables: `currentMax` (la suma máxima que termina en el índice actual) y `globalMax` (la suma máxima encontrada hasta ahora). En cada paso, la `currentMax` se decide entre empezar una nueva submatriz en el número actual (`nums[i]`) o extender la submatriz anterior (`currentMax + nums[i]`). El `globalMax` simplemente rastrea el valor más alto de `currentMax` visto.",
                "code_snippet": "function maxSubArray(nums) {\n    if (nums.length === 0) return 0;\n    \n    let currentMax = nums[0];\n    let globalMax = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        // La nueva suma máxima que termina en 'i' es el número actual\n        // O el número actual sumado a la suma máxima anterior.\n        currentMax = Math.max(nums[i], currentMax + nums[i]);\n        \n        // Actualizar la suma máxima global\n        globalMax = Math.max(globalMax, currentMax);\n    }\n    return globalMax;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]",
                                "result": "6 (Submatriz: [4, -1, 2, 1])"
                            },
                            "code_line": "return resultado",
                            "output": "6 (Submatriz: [4, -1, 2, 1])"
                        }
                    ],
                    "final_output": "6 (Submatriz: [4, -1, 2, 1])"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function maxSubArray(nums) {\n    if (nums.length === 0) return 0;\n    \n    let currentMax = nums[0];\n    let globalMax = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        // La nueva suma máxima que termina en 'i' es el número actual\n        // O el número actual sumado a la suma máxima anterior.\n        currentMax = Math.max(nums[i], currentMax + nums[i]);\n        \n        // Actualizar la suma máxima global\n        globalMax = Math.max(globalMax, currentMax);\n    }\n    return globalMax;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]",
                                "result": "6 (Submatriz: [4, -1, 2, 1])"
                            },
                            "code_line": "return resultado",
                            "output": "6 (Submatriz: [4, -1, 2, 1])"
                        }
                    ],
                    "final_output": "6 (Submatriz: [4, -1, 2, 1])"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function maxSubArray(nums) {\n    if (nums.length === 0) return 0;\n    \n    let currentMax = nums[0];\n    let globalMax = nums[0];\n    \n    for (let i = 1; i < nums.length; i++) {\n        // La nueva suma máxima que termina en 'i' es el número actual\n        // O el número actual sumado a la suma máxima anterior.\n        currentMax = Math.max(nums[i], currentMax + nums[i]);\n        \n        // Actualizar la suma máxima global\n        globalMax = Math.max(globalMax, currentMax);\n    }\n    return globalMax;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[-2, 1, -3, 4, -1, 2, 1, -5, 4]",
                                "result": "6 (Submatriz: [4, -1, 2, 1])"
                            },
                            "code_line": "return resultado",
                            "output": "6 (Submatriz: [4, -1, 2, 1])"
                        }
                    ],
                    "final_output": "6 (Submatriz: [4, -1, 2, 1])"
                }
            }
        ]
    },
    {
        "id": "single-number",
        "title": "136. Single Number",
        "difficulty": "Easy",
        "description": "Dada una matriz no vacía de enteros `nums`, cada elemento aparece dos veces excepto uno. Encuentra ese único elemento.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: XOR (Propiedad Exclusiva OR)",
                "explanation": "Esta es la solución más eficiente y utiliza las propiedades del operador XOR (`^`). La propiedad clave es que $A \\oplus A = 0$ y $A \\oplus 0 = A$. Al aplicar XOR a todos los elementos del array, los pares de números idénticos se cancelan (resultando en 0), y el número único, al hacer XOR con 0, queda como el resultado final.",
                "code_snippet": "function singleNumber(nums) {\n    let result = 0;\n    for (const num of nums) {\n        result ^= num;\n    }\n    return result;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[4, 1, 2, 1, 2]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[4, 1, 2, 1, 2]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[4, 1, 2, 1, 2]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[4, 1, 2, 1, 2]",
                                "result": "4"
                            },
                            "code_line": "return resultado",
                            "output": "4"
                        }
                    ],
                    "final_output": "4"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function singleNumber(nums) {\n    let result = 0;\n    for (const num of nums) {\n        result ^= num;\n    }\n    return result;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[4, 1, 2, 1, 2]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[4, 1, 2, 1, 2]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[4, 1, 2, 1, 2]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[4, 1, 2, 1, 2]",
                                "result": "4"
                            },
                            "code_line": "return resultado",
                            "output": "4"
                        }
                    ],
                    "final_output": "4"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function singleNumber(nums) {\n    let result = 0;\n    for (const num of nums) {\n        result ^= num;\n    }\n    return result;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[4, 1, 2, 1, 2]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[4, 1, 2, 1, 2]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[4, 1, 2, 1, 2]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[4, 1, 2, 1, 2]",
                                "result": "4"
                            },
                            "code_line": "return resultado",
                            "output": "4"
                        }
                    ],
                    "final_output": "4"
                }
            }
        ]
    },
    {
        "id": "move-zeroes",
        "title": "283. Move Zeroes",
        "difficulty": "Easy",
        "description": "Dado un array `nums`, mueve todos los ceros al final de este, mientras mantienes el orden relativo de los elementos no cero. Debes hacerlo *in place* sin hacer una copia del array.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Two Pointers (Puntero de Escritura)",
                "explanation": "Usamos un puntero (`nonZeroIndex`) para rastrear dónde se debe colocar el siguiente elemento no cero. Recorremos el array con otro puntero (`i`). Si `nums[i]` no es cero, lo colocamos en `nums[nonZeroIndex]` y avanzamos `nonZeroIndex`. Esto garantiza que todos los elementos no cero se muevan al principio en su orden original. Al finalizar el primer bucle, todos los elementos desde `nonZeroIndex` hasta el final son ceros, y simplemente los sobrescribimos con 0.",
                "code_snippet": "function moveZeroes(nums) {\n    let nonZeroIndex = 0;\n    \n    // Paso 1: Mover todos los no-ceros al frente\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== 0) {\n            nums[nonZeroIndex] = nums[i];\n            nonZeroIndex++;\n        }\n    }\n    \n    // Paso 2: Llenar el resto del array con ceros\n    for (let i = nonZeroIndex; i < nums.length; i++) {\n        nums[i] = 0;\n    }\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[0, 1, 0, 3, 12]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[0, 1, 0, 3, 12]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[0, 1, 0, 3, 12]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[0, 1, 0, 3, 12]",
                                "result": "[1, 3, 12, 0, 0]"
                            },
                            "code_line": "return resultado",
                            "output": "[1, 3, 12, 0, 0]"
                        }
                    ],
                    "final_output": "[1, 3, 12, 0, 0]"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function moveZeroes(nums) {\n    let nonZeroIndex = 0;\n    \n    // Paso 1: Mover todos los no-ceros al frente\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== 0) {\n            nums[nonZeroIndex] = nums[i];\n            nonZeroIndex++;\n        }\n    }\n    \n    // Paso 2: Llenar el resto del array con ceros\n    for (let i = nonZeroIndex; i < nums.length; i++) {\n        nums[i] = 0;\n    }\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[0, 1, 0, 3, 12]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[0, 1, 0, 3, 12]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[0, 1, 0, 3, 12]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[0, 1, 0, 3, 12]",
                                "result": "[1, 3, 12, 0, 0]"
                            },
                            "code_line": "return resultado",
                            "output": "[1, 3, 12, 0, 0]"
                        }
                    ],
                    "final_output": "[1, 3, 12, 0, 0]"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function moveZeroes(nums) {\n    let nonZeroIndex = 0;\n    \n    // Paso 1: Mover todos los no-ceros al frente\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== 0) {\n            nums[nonZeroIndex] = nums[i];\n            nonZeroIndex++;\n        }\n    }\n    \n    // Paso 2: Llenar el resto del array con ceros\n    for (let i = nonZeroIndex; i < nums.length; i++) {\n        nums[i] = 0;\n    }\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[0, 1, 0, 3, 12]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[0, 1, 0, 3, 12]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[0, 1, 0, 3, 12]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[0, 1, 0, 3, 12]",
                                "result": "[1, 3, 12, 0, 0]"
                            },
                            "code_line": "return resultado",
                            "output": "[1, 3, 12, 0, 0]"
                        }
                    ],
                    "final_output": "[1, 3, 12, 0, 0]"
                }
            }
        ]
    },
    {
        "id": "reverse-string",
        "title": "344. Reverse String",
        "difficulty": "Easy",
        "description": "Escribe una función que invierta una cadena. La cadena de entrada se da como un array de caracteres `s`. Debes hacerlo *in place* con O(1) de espacio extra.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Two Pointers (Intercambio)",
                "explanation": "Esta técnica es ideal para operaciones *in place*. Inicializamos dos punteros: `left` al inicio y `right` al final. En cada iteración, intercambiamos los caracteres en las posiciones `left` y `right`, y luego movemos `left` una posición a la derecha y `right` una posición a la izquierda. El proceso se detiene cuando `left` es mayor o igual a `right`.",
                "code_snippet": "function reverseString(s) {\n    let left = 0;\n    let right = s.length - 1;\n    while (left < right) {\n        // Intercambio\n        [s[left], s[right]] = [s[right], s[left]];\n        left++;\n        right--;\n    }\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[\"h\",\"e\",\"l\",\"l\",\"o\"]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[\"h\",\"e\",\"l\",\"l\",\"o\"]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[\"h\",\"e\",\"l\",\"l\",\"o\"]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[\"h\",\"e\",\"l\",\"l\",\"o\"]",
                                "result": "[\"o\",\"l\",\"l\",\"e\",\"h\"]"
                            },
                            "code_line": "return resultado",
                            "output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]"
                        }
                    ],
                    "final_output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function reverseString(s) {\n    let left = 0;\n    let right = s.length - 1;\n    while (left < right) {\n        // Intercambio\n        [s[left], s[right]] = [s[right], s[left]];\n        left++;\n        right--;\n    }\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[\"h\",\"e\",\"l\",\"l\",\"o\"]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[\"h\",\"e\",\"l\",\"l\",\"o\"]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[\"h\",\"e\",\"l\",\"l\",\"o\"]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[\"h\",\"e\",\"l\",\"l\",\"o\"]",
                                "result": "[\"o\",\"l\",\"l\",\"e\",\"h\"]"
                            },
                            "code_line": "return resultado",
                            "output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]"
                        }
                    ],
                    "final_output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function reverseString(s) {\n    let left = 0;\n    let right = s.length - 1;\n    while (left < right) {\n        // Intercambio\n        [s[left], s[right]] = [s[right], s[left]];\n        left++;\n        right--;\n    }\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[\"h\",\"e\",\"l\",\"l\",\"o\"]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[\"h\",\"e\",\"l\",\"l\",\"o\"]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[\"h\",\"e\",\"l\",\"l\",\"o\"]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[\"h\",\"e\",\"l\",\"l\",\"o\"]",
                                "result": "[\"o\",\"l\",\"l\",\"e\",\"h\"]"
                            },
                            "code_line": "return resultado",
                            "output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]"
                        }
                    ],
                    "final_output": "[\"o\",\"l\",\"l\",\"e\",\"h\"]"
                }
            }
        ]
    },
    {
        "id": "fizz-buzz",
        "title": "412. Fizz Buzz",
        "difficulty": "Easy",
        "description": "Escribe un programa que imprima los números del 1 al `n`. Para múltiplos de tres, imprime “Fizz”; para múltiplos de cinco, imprime “Buzz”; y para múltiplos de tres y cinco, imprime “FizzBuzz”.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Clásica con Módulo",
                "explanation": "Iteramos desde 1 hasta `n`. Es crucial verificar primero el caso de divisibilidad por 3 y 5 (es decir, divisibilidad por 15), ya que si verificamos 3 y 5 por separado primero, el caso 'FizzBuzz' nunca se alcanzaría. El operador de módulo (`%`) nos permite determinar la divisibilidad.",
                "code_snippet": "function fizzBuzz(n) {\n    const result = [];\n    for (let i = 1; i <= n; i++) {\n        let output = \"\";\n        \n        // Caso 1: Múltiplo de 3 y 5 (15)\n        if (i % 3 === 0 && i % 5 === 0) {\n            output = \"FizzBuzz\";\n        // Caso 2: Múltiplo de 3\n        } else if (i % 3 === 0) {\n            output = \"Fizz\";\n        // Caso 3: Múltiplo de 5\n        } else if (i % 5 === 0) {\n            output = \"Buzz\";\n        // Caso 4: Ninguno de los anteriores\n        } else {\n            output = i.toString();\n        }\n        result.push(output);\n    }\n    return result;\n}",
                "complexity": "Time: O(N), Space: O(N)",
                "example": {
                    "input": "5",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "5"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "5",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "5",
                                "result": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]"
                            },
                            "code_line": "return resultado",
                            "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]"
                        }
                    ],
                    "final_output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function fizzBuzz(n) {\n    const result = [];\n    for (let i = 1; i <= n; i++) {\n        let output = \"\";\n        \n        // Caso 1: Múltiplo de 3 y 5 (15)\n        if (i % 3 === 0 && i % 5 === 0) {\n            output = \"FizzBuzz\";\n        // Caso 2: Múltiplo de 3\n        } else if (i % 3 === 0) {\n            output = \"Fizz\";\n        // Caso 3: Múltiplo de 5\n        } else if (i % 5 === 0) {\n            output = \"Buzz\";\n        // Caso 4: Ninguno de los anteriores\n        } else {\n            output = i.toString();\n        }\n        result.push(output);\n    }\n    return result;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(N)",
                "example": {
                    "input": "5",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "5"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "5",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "5",
                                "result": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]"
                            },
                            "code_line": "return resultado",
                            "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]"
                        }
                    ],
                    "final_output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function fizzBuzz(n) {\n    const result = [];\n    for (let i = 1; i <= n; i++) {\n        let output = \"\";\n        \n        // Caso 1: Múltiplo de 3 y 5 (15)\n        if (i % 3 === 0 && i % 5 === 0) {\n            output = \"FizzBuzz\";\n        // Caso 2: Múltiplo de 3\n        } else if (i % 3 === 0) {\n            output = \"Fizz\";\n        // Caso 3: Múltiplo de 5\n        } else if (i % 5 === 0) {\n            output = \"Buzz\";\n        // Caso 4: Ninguno de los anteriores\n        } else {\n            output = i.toString();\n        }\n        result.push(output);\n    }\n    return result;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(N)",
                "example": {
                    "input": "5",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "5"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "5",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "5",
                                "result": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]"
                            },
                            "code_line": "return resultado",
                            "output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]"
                        }
                    ],
                    "final_output": "[\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]"
                }
            }
        ]
    },
    {
        "id": "best-time-to-buy-and-sell-stock",
        "title": "121. Best Time to Buy and Sell Stock",
        "difficulty": "Easy",
        "description": "Dado un array `prices` donde `prices[i]` es el precio de una acción en el día `i`. Encuentra la ganancia máxima que puedes lograr al completar una transacción (comprar una y vender una).",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Una Pasada (Min Price Tracking)",
                "explanation": "Solo necesitamos encontrar el día de compra más bajo *antes* de cada día de venta. Iteramos sobre los precios, manteniendo un registro del precio más bajo visto hasta ahora (`minPrice`). Para el precio actual, calculamos la ganancia potencial (`price - minPrice`) y actualizamos la ganancia máxima global (`maxProfit`) si esta ganancia potencial es mayor. Esto garantiza que la compra siempre ocurra antes de la venta.",
                "code_snippet": "function maxProfit(prices) {\n    let minPrice = Infinity; // Inicializar con un valor muy grande\n    let maxProfit = 0;\n    \n    for (const price of prices) {\n        // 1. Encontrar el precio más bajo hasta el momento\n        minPrice = Math.min(minPrice, price);\n        \n        // 2. Calcular la ganancia potencial si vendemos hoy\n        const potentialProfit = price - minPrice;\n        \n        // 3. Actualizar la ganancia máxima global\n        maxProfit = Math.max(maxProfit, potentialProfit);\n    }\n    return maxProfit;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[7, 1, 5, 3, 6, 4]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[7, 1, 5, 3, 6, 4]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[7, 1, 5, 3, 6, 4]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[7, 1, 5, 3, 6, 4]",
                                "result": "5 (Comprar en 1, vender en 6)"
                            },
                            "code_line": "return resultado",
                            "output": "5 (Comprar en 1, vender en 6)"
                        }
                    ],
                    "final_output": "5 (Comprar en 1, vender en 6)"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function maxProfit(prices) {\n    let minPrice = Infinity; // Inicializar con un valor muy grande\n    let maxProfit = 0;\n    \n    for (const price of prices) {\n        // 1. Encontrar el precio más bajo hasta el momento\n        minPrice = Math.min(minPrice, price);\n        \n        // 2. Calcular la ganancia potencial si vendemos hoy\n        const potentialProfit = price - minPrice;\n        \n        // 3. Actualizar la ganancia máxima global\n        maxProfit = Math.max(maxProfit, potentialProfit);\n    }\n    return maxProfit;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[7, 1, 5, 3, 6, 4]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[7, 1, 5, 3, 6, 4]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[7, 1, 5, 3, 6, 4]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[7, 1, 5, 3, 6, 4]",
                                "result": "5 (Comprar en 1, vender en 6)"
                            },
                            "code_line": "return resultado",
                            "output": "5 (Comprar en 1, vender en 6)"
                        }
                    ],
                    "final_output": "5 (Comprar en 1, vender en 6)"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function maxProfit(prices) {\n    let minPrice = Infinity; // Inicializar con un valor muy grande\n    let maxProfit = 0;\n    \n    for (const price of prices) {\n        // 1. Encontrar el precio más bajo hasta el momento\n        minPrice = Math.min(minPrice, price);\n        \n        // 2. Calcular la ganancia potencial si vendemos hoy\n        const potentialProfit = price - minPrice;\n        \n        // 3. Actualizar la ganancia máxima global\n        maxProfit = Math.max(maxProfit, potentialProfit);\n    }\n    return maxProfit;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[7, 1, 5, 3, 6, 4]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[7, 1, 5, 3, 6, 4]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[7, 1, 5, 3, 6, 4]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[7, 1, 5, 3, 6, 4]",
                                "result": "5 (Comprar en 1, vender en 6)"
                            },
                            "code_line": "return resultado",
                            "output": "5 (Comprar en 1, vender en 6)"
                        }
                    ],
                    "final_output": "5 (Comprar en 1, vender en 6)"
                }
            }
        ]
    },
    {
        "id": "contains-duplicate",
        "title": "217. Contains Duplicate",
        "difficulty": "Easy",
        "description": "Dado un array de enteros `nums`, devuelve `true` si algún valor aparece al menos dos veces en el array, y `false` si cada elemento es distinto.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Hash Set",
                "explanation": "La forma más eficiente es usar un Set (conjunto hash) para almacenar los números que ya hemos encontrado. Un Set permite inserciones y verificaciones de existencia en tiempo promedio O(1). Iteramos sobre el array; si el número actual ya está en el Set, devolvemos `true`. De lo contrario, lo agregamos al Set.",
                "code_snippet": "function containsDuplicate(nums) {\n    const seen = new Set();\n    for (const num of nums) {\n        if (seen.has(num)) {\n            return true; // Duplicado encontrado\n        }\n        seen.add(num);\n    }\n    return false; // No se encontraron duplicados\n}",
                "complexity": "Time: O(N), Space: O(N)",
                "example": {
                    "input": "[1, 2, 3, 1]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[1, 2, 3, 1]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[1, 2, 3, 1]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[1, 2, 3, 1]",
                                "result": "true"
                            },
                            "code_line": "return resultado",
                            "output": "true"
                        }
                    ],
                    "final_output": "true"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function containsDuplicate(nums) {\n    const seen = new Set();\n    for (const num of nums) {\n        if (seen.has(num)) {\n            return true; // Duplicado encontrado\n        }\n        seen.add(num);\n    }\n    return false; // No se encontraron duplicados\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(N)",
                "example": {
                    "input": "[1, 2, 3, 1]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[1, 2, 3, 1]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[1, 2, 3, 1]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[1, 2, 3, 1]",
                                "result": "true"
                            },
                            "code_line": "return resultado",
                            "output": "true"
                        }
                    ],
                    "final_output": "true"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function containsDuplicate(nums) {\n    const seen = new Set();\n    for (const num of nums) {\n        if (seen.has(num)) {\n            return true; // Duplicado encontrado\n        }\n        seen.add(num);\n    }\n    return false; // No se encontraron duplicados\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(N)",
                "example": {
                    "input": "[1, 2, 3, 1]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[1, 2, 3, 1]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[1, 2, 3, 1]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[1, 2, 3, 1]",
                                "result": "true"
                            },
                            "code_line": "return resultado",
                            "output": "true"
                        }
                    ],
                    "final_output": "true"
                }
            }
        ]
    },
    {
        "id": "invert-binary-tree",
        "title": "226. Invert Binary Tree",
        "difficulty": "Easy",
        "description": "Invertir un árbol binario. Es decir, intercambiar los nodos hijos izquierdo y derecho de cada nodo.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Recursión (DFS)",
                "explanation": "La inversión de un árbol binario se logra recursivamente. Para cualquier nodo, su tarea es simplemente intercambiar sus hijos izquierdo y derecho. Luego, llama a la función de inversión recursivamente en el nuevo subárbol izquierdo (que era el derecho original) y en el nuevo subárbol derecho (que era el izquierdo original). El caso base es cuando el nodo es `null`.",
                "code_snippet": "function invertTree(root) {\n    if (root === null) {\n        return null;\n    }\n    \n    // Intercambiar los hijos\n    const left = root.left;\n    root.left = root.right;\n    root.right = left;\n    \n    // Invertir recursivamente los subárboles\n    invertTree(root.left);\n    invertTree(root.right);\n    \n    return root;\n}",
                "complexity": "Time: O(N), Space: O(H) [Altura del árbol]",
                "example": {
                    "input": "[4, 2, 7, 1, 3, 6, 9]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[4, 2, 7, 1, 3, 6, 9]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[4, 2, 7, 1, 3, 6, 9]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[4, 2, 7, 1, 3, 6, 9]",
                                "result": "[4, 7, 2, 9, 6, 3, 1]"
                            },
                            "code_line": "return resultado",
                            "output": "[4, 7, 2, 9, 6, 3, 1]"
                        }
                    ],
                    "final_output": "[4, 7, 2, 9, 6, 3, 1]"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function invertTree(root) {\n    if (root === null) {\n        return null;\n    }\n    \n    // Intercambiar los hijos\n    const left = root.left;\n    root.left = root.right;\n    root.right = left;\n    \n    // Invertir recursivamente los subárboles\n    invertTree(root.left);\n    invertTree(root.right);\n    \n    return root;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(H) [Altura del árbol]",
                "example": {
                    "input": "[4, 2, 7, 1, 3, 6, 9]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[4, 2, 7, 1, 3, 6, 9]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[4, 2, 7, 1, 3, 6, 9]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[4, 2, 7, 1, 3, 6, 9]",
                                "result": "[4, 7, 2, 9, 6, 3, 1]"
                            },
                            "code_line": "return resultado",
                            "output": "[4, 7, 2, 9, 6, 3, 1]"
                        }
                    ],
                    "final_output": "[4, 7, 2, 9, 6, 3, 1]"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function invertTree(root) {\n    if (root === null) {\n        return null;\n    }\n    \n    // Intercambiar los hijos\n    const left = root.left;\n    root.left = root.right;\n    root.right = left;\n    \n    // Invertir recursivamente los subárboles\n    invertTree(root.left);\n    invertTree(root.right);\n    \n    return root;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(H) [Altura del árbol]",
                "example": {
                    "input": "[4, 2, 7, 1, 3, 6, 9]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[4, 2, 7, 1, 3, 6, 9]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[4, 2, 7, 1, 3, 6, 9]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[4, 2, 7, 1, 3, 6, 9]",
                                "result": "[4, 7, 2, 9, 6, 3, 1]"
                            },
                            "code_line": "return resultado",
                            "output": "[4, 7, 2, 9, 6, 3, 1]"
                        }
                    ],
                    "final_output": "[4, 7, 2, 9, 6, 3, 1]"
                }
            }
        ]
    },
    {
        "id": "palindrome-number",
        "title": "009. Palindrome Number",
        "difficulty": "Easy",
        "description": "Dado un entero `x`, devuelve `true` si `x` es un palíndromo. Un entero es un palíndromo cuando se lee igual de adelante hacia atrás.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Revertir la Mitad del Número",
                "explanation": "Para evitar el desbordamiento de enteros que podría ocurrir al revertir el número completo, solo revertimos la mitad del número. Primero, manejamos los casos triviales (números negativos o números terminados en 0). Luego, construimos el número `revertedNumber` con los dígitos de la mitad inferior de `x`. El bucle se detiene cuando `x` es menor o igual a `revertedNumber`. Finalmente, verificamos si `x` es igual a `revertedNumber` (para números de longitud par) o `revertedNumber` dividido por 10 (para números de longitud impar).",
                "code_snippet": "function isPalindrome(x) {\n    // Caso especial: números negativos o números terminados en 0 (excepto el 0 mismo)\n    if (x < 0 || (x % 10 === 0 && x !== 0)) {\n        return false;\n    }\n    \n    let revertedNumber = 0;\n    while (x > revertedNumber) {\n        revertedNumber = revertedNumber * 10 + (x % 10);\n        x = Math.floor(x / 10);\n    }\n    \n    // Para longitud par: x === revertedNumber\n    // Para longitud impar: x === Math.floor(revertedNumber / 10)\n    return x === revertedNumber || x === Math.floor(revertedNumber / 10);\n}",
                "complexity": "Time: O(log N), Space: O(1)",
                "example": {
                    "input": "121",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "121"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "121",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "121",
                                "result": "true"
                            },
                            "code_line": "return resultado",
                            "output": "true"
                        }
                    ],
                    "final_output": "true"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function isPalindrome(x) {\n    // Caso especial: números negativos o números terminados en 0 (excepto el 0 mismo)\n    if (x < 0 || (x % 10 === 0 && x !== 0)) {\n        return false;\n    }\n    \n    let revertedNumber = 0;\n    while (x > revertedNumber) {\n        revertedNumber = revertedNumber * 10 + (x % 10);\n        x = Math.floor(x / 10);\n    }\n    \n    // Para longitud par: x === revertedNumber\n    // Para longitud impar: x === Math.floor(revertedNumber / 10)\n    return x === revertedNumber || x === Math.floor(revertedNumber / 10);\n} // Variación alternativa",
                "complexity": "Time: O(log N), Space: O(1)",
                "example": {
                    "input": "121",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "121"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "121",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "121",
                                "result": "true"
                            },
                            "code_line": "return resultado",
                            "output": "true"
                        }
                    ],
                    "final_output": "true"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function isPalindrome(x) {\n    // Caso especial: números negativos o números terminados en 0 (excepto el 0 mismo)\n    if (x < 0 || (x % 10 === 0 && x !== 0)) {\n        return false;\n    }\n    \n    let revertedNumber = 0;\n    while (x > revertedNumber) {\n        revertedNumber = revertedNumber * 10 + (x % 10);\n        x = Math.floor(x / 10);\n    }\n    \n    // Para longitud par: x === revertedNumber\n    // Para longitud impar: x === Math.floor(revertedNumber / 10)\n    return x === revertedNumber || x === Math.floor(revertedNumber / 10);\n} // Variación alternativa",
                "complexity": "Time: O(log N), Space: O(1)",
                "example": {
                    "input": "121",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "121"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "121",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "121",
                                "result": "true"
                            },
                            "code_line": "return resultado",
                            "output": "true"
                        }
                    ],
                    "final_output": "true"
                }
            }
        ]
    },
    {
        "id": "roman-to-integer",
        "title": "013. Roman to Integer",
        "difficulty": "Easy",
        "description": "Dado un número romano, conviértelo a un entero. Se garantiza que la entrada está en el rango de 1 a 3999.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Iteración con Regla de Sustracción",
                "explanation": "Los números romanos se leen de izquierda a derecha sumando sus valores, excepto cuando un símbolo de menor valor precede a uno de mayor valor (la regla de sustracción, ej: IV = 4). Utilizamos un mapa para asignar valores. Iteramos de derecha a izquierda o, como en esta solución, de izquierda a derecha. Si el valor del símbolo actual es menor que el valor del siguiente, lo restamos; de lo contrario, lo sumamos.",
                "code_snippet": "function romanToInt(s) {\n    const map = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    };\n    \n    let result = 0;\n    \n    for (let i = 0; i < s.length; i++) {\n        const currentVal = map[s[i]];\n        const nextVal = map[s[i + 1]];\n        \n        if (nextVal > currentVal) {\n            // Aplicar la regla de sustracción (ej. IV = 5 - 1)\n            result += (nextVal - currentVal);\n            i++; // Saltar el siguiente símbolo ya que fue procesado\n        } else {\n            result += currentVal;\n        }\n    }\n    return result;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "\"LVIII\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "\"LVIII\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "\"LVIII\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "\"LVIII\"",
                                "result": "58"
                            },
                            "code_line": "return resultado",
                            "output": "58"
                        }
                    ],
                    "final_output": "58"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Fuerza Bruta (Alternativa)",
                "explanation": "Una aproximación de fuerza bruta que explora todas las posibles combinaciones. Aunque menos eficiente en términos de complejidad temporal, es más fácil de entender y puede ser útil para problemas pequeños o como punto de partida para optimizaciones.",
                "code_snippet": "function romanToInt(s) {\n    const map = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    };\n    \n    let result = 0;\n    \n    for (let i = 0; i < s.length; i++) {\n        const currentVal = map[s[i]];\n        const nextVal = map[s[i + 1]];\n        \n        if (nextVal > currentVal) {\n            // Aplicar la regla de sustracción (ej. IV = 5 - 1)\n            result += (nextVal - currentVal);\n            i++; // Saltar el siguiente símbolo ya que fue procesado\n        } else {\n            result += currentVal;\n        }\n    }\n    return result;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "\"LVIII\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "\"LVIII\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "\"LVIII\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "\"LVIII\"",
                                "result": "58"
                            },
                            "code_line": "return resultado",
                            "output": "58"
                        }
                    ],
                    "final_output": "58"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Recursiva con Memoización",
                "explanation": "Una solución recursiva que divide el problema en subproblemas más pequeños. Usa memoización para almacenar los resultados de subproblemas ya calculados, evitando cálculos repetidos y mejorando significativamente el rendimiento sobre la recursión pura.",
                "code_snippet": "function romanToInt(s) {\n    const map = {\n        'I': 1, 'V': 5, 'X': 10, 'L': 50,\n        'C': 100, 'D': 500, 'M': 1000\n    };\n    \n    let result = 0;\n    \n    for (let i = 0; i < s.length; i++) {\n        const currentVal = map[s[i]];\n        const nextVal = map[s[i + 1]];\n        \n        if (nextVal > currentVal) {\n            // Aplicar la regla de sustracción (ej. IV = 5 - 1)\n            result += (nextVal - currentVal);\n            i++; // Saltar el siguiente símbolo ya que fue procesado\n        } else {\n            result += currentVal;\n        }\n    }\n    return result;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "\"LVIII\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "\"LVIII\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "\"LVIII\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "\"LVIII\"",
                                "result": "58"
                            },
                            "code_line": "return resultado",
                            "output": "58"
                        }
                    ],
                    "final_output": "58"
                }
            }
        ]
    },
    {
        "id": "longest-common-prefix",
        "title": "014. Longest Common Prefix",
        "difficulty": "Easy",
        "description": "Escribe una función para encontrar la cadena de prefijo común más larga entre un array de cadenas.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Exploración Horizontal (Horizontal Scanning)",
                "explanation": "Asumimos inicialmente que el primer string es el prefijo común. Luego, iteramos sobre el resto de las strings, acortando el prefijo común actual si no es un prefijo de la string que estamos examinando. La función `indexOf(prefix) === 0` verifica eficientemente si `prefix` es el prefijo de la string actual. Si el prefijo se acorta a una cadena vacía, no hay prefijo común.",
                "code_snippet": "function longestCommonPrefix(strs) {\n    if (!strs || strs.length === 0) return \"\";\n    \n    let prefix = strs[0];\n    \n    // Iterar a través de las cadenas restantes\n    for (let i = 1; i < strs.length; i++) {\n        let currentStr = strs[i];\n        \n        // Mientras el prefijo no se encuentre al inicio de currentStr\n        while (currentStr.indexOf(prefix) !== 0) {\n            // Acortar el prefijo en un carácter\n            prefix = prefix.substring(0, prefix.length - 1);\n            \n            // Si el prefijo se vacía, no hay prefijo común\n            if (prefix.length === 0) return \"\";\n        }\n    }\n    \n    return prefix;\n}",
                "complexity": "Time: O(S), donde S es la suma de todas las longitudes de las strings. En el peor caso, O(N * M), donde N es el número de strings y M es la longitud de la string más corta.",
                "example": {
                    "input": "[\"flower\",\"flow\",\"flight\"]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[\"flower\",\"flow\",\"flight\"]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[\"flower\",\"flow\",\"flight\"]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[\"flower\",\"flow\",\"flight\"]",
                                "result": "\"fl\""
                            },
                            "code_line": "return resultado",
                            "output": "\"fl\""
                        }
                    ],
                    "final_output": "\"fl\""
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function longestCommonPrefix(strs) {\n    if (!strs || strs.length === 0) return \"\";\n    \n    let prefix = strs[0];\n    \n    // Iterar a través de las cadenas restantes\n    for (let i = 1; i < strs.length; i++) {\n        let currentStr = strs[i];\n        \n        // Mientras el prefijo no se encuentre al inicio de currentStr\n        while (currentStr.indexOf(prefix) !== 0) {\n            // Acortar el prefijo en un carácter\n            prefix = prefix.substring(0, prefix.length - 1);\n            \n            // Si el prefijo se vacía, no hay prefijo común\n            if (prefix.length === 0) return \"\";\n        }\n    }\n    \n    return prefix;\n} // Variación alternativa",
                "complexity": "Time: O(S), donde S es la suma de todas las longitudes de las strings. En el peor caso, O(N * M), donde N es el número de strings y M es la longitud de la string más corta.",
                "example": {
                    "input": "[\"flower\",\"flow\",\"flight\"]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[\"flower\",\"flow\",\"flight\"]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[\"flower\",\"flow\",\"flight\"]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[\"flower\",\"flow\",\"flight\"]",
                                "result": "\"fl\""
                            },
                            "code_line": "return resultado",
                            "output": "\"fl\""
                        }
                    ],
                    "final_output": "\"fl\""
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function longestCommonPrefix(strs) {\n    if (!strs || strs.length === 0) return \"\";\n    \n    let prefix = strs[0];\n    \n    // Iterar a través de las cadenas restantes\n    for (let i = 1; i < strs.length; i++) {\n        let currentStr = strs[i];\n        \n        // Mientras el prefijo no se encuentre al inicio de currentStr\n        while (currentStr.indexOf(prefix) !== 0) {\n            // Acortar el prefijo en un carácter\n            prefix = prefix.substring(0, prefix.length - 1);\n            \n            // Si el prefijo se vacía, no hay prefijo común\n            if (prefix.length === 0) return \"\";\n        }\n    }\n    \n    return prefix;\n} // Variación alternativa",
                "complexity": "Time: O(S), donde S es la suma de todas las longitudes de las strings. En el peor caso, O(N * M), donde N es el número de strings y M es la longitud de la string más corta.",
                "example": {
                    "input": "[\"flower\",\"flow\",\"flight\"]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[\"flower\",\"flow\",\"flight\"]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[\"flower\",\"flow\",\"flight\"]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[\"flower\",\"flow\",\"flight\"]",
                                "result": "\"fl\""
                            },
                            "code_line": "return resultado",
                            "output": "\"fl\""
                        }
                    ],
                    "final_output": "\"fl\""
                }
            }
        ]
    },
    {
        "id": "median-of-two-sorted-arrays",
        "title": "004. Median of Two Sorted Arrays",
        "difficulty": "Hard",
        "description": "Dados dos arrays ordenados `nums1` y `nums2` de tamaño `m` y `n` respectivamente, devuelve la mediana de los dos arrays ordenados. El tiempo de ejecución general debe ser O(log(m+n)).",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Búsqueda Binaria en Particiones (Optimal O(log(min(m, n))))",
                "explanation": "La clave es encontrar la partición correcta (`partitionX` y `partitionY`) que divida ambos arrays en dos mitades, de modo que todos los elementos en la mitad izquierda sean menores o iguales a todos los elementos en la mitad derecha. Se aplica búsqueda binaria al array más pequeño (para garantizar O(log(min(m, n)))). Si la condición se cumple, la mediana se calcula a partir de los elementos máximos de la izquierda y mínimos de la derecha.",
                "code_snippet": "function findMedianSortedArrays(nums1, nums2) {\n    // Aseguramos que nums1 sea el array más pequeño para O(log(min(m,n)))\n    if (nums1.length > nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    const x = nums1.length;\n    const y = nums2.length;\n    let low = 0;\n    let high = x;\n    \n    while (low <= high) {\n        const partitionX = Math.floor((low + high) / 2);\n        // (x + y + 1) para manejar ambos casos de longitud par e impar\n        const partitionY = Math.floor((x + y + 1) / 2) - partitionX;\n        \n        // Determinar maxLeft y minRight para las cuatro esquinas de las particiones\n        const maxX = (partitionX === 0) ? -Infinity : nums1[partitionX - 1];\n        const minX = (partitionX === x) ? Infinity : nums1[partitionX];\n        \n        const maxY = (partitionY === 0) ? -Infinity : nums2[partitionY - 1];\n        const minY = (partitionY === y) ? Infinity : nums2[partitionY];\n        \n        if (maxX <= minY && maxY <= minX) {\n            // Partición correcta encontrada\n            if ((x + y) % 2 === 0) {\n                // Caso par\n                return (Math.max(maxX, maxY) + Math.min(minX, minY)) / 2;\n            } else {\n                // Caso impar\n                return Math.max(maxX, maxY);\n            }\n        } else if (maxX > minY) {\n            // Necesitamos mover la particiónX hacia la izquierda\n            high = partitionX - 1;\n        } else {\n            // Necesitamos mover la particiónX hacia la derecha\n            low = partitionX + 1;\n        }\n    }\n}",
                "complexity": "Time: O(log(min(M, N))), Space: O(1)",
                "example": {
                    "input": "nums1 = [1, 3], nums2 = [2]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "nums1 = [1, 3], nums2 = [2]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "nums1 = [1, 3], nums2 = [2]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "nums1 = [1, 3], nums2 = [2]",
                                "result": "2.0"
                            },
                            "code_line": "return resultado",
                            "output": "2.0"
                        }
                    ],
                    "final_output": "2.0"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function findMedianSortedArrays(nums1, nums2) {\n    // Aseguramos que nums1 sea el array más pequeño para O(log(min(m,n)))\n    if (nums1.length > nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    const x = nums1.length;\n    const y = nums2.length;\n    let low = 0;\n    let high = x;\n    \n    while (low <= high) {\n        const partitionX = Math.floor((low + high) / 2);\n        // (x + y + 1) para manejar ambos casos de longitud par e impar\n        const partitionY = Math.floor((x + y + 1) / 2) - partitionX;\n        \n        // Determinar maxLeft y minRight para las cuatro esquinas de las particiones\n        const maxX = (partitionX === 0) ? -Infinity : nums1[partitionX - 1];\n        const minX = (partitionX === x) ? Infinity : nums1[partitionX];\n        \n        const maxY = (partitionY === 0) ? -Infinity : nums2[partitionY - 1];\n        const minY = (partitionY === y) ? Infinity : nums2[partitionY];\n        \n        if (maxX <= minY && maxY <= minX) {\n            // Partición correcta encontrada\n            if ((x + y) % 2 === 0) {\n                // Caso par\n                return (Math.max(maxX, maxY) + Math.min(minX, minY)) / 2;\n            } else {\n                // Caso impar\n                return Math.max(maxX, maxY);\n            }\n        } else if (maxX > minY) {\n            // Necesitamos mover la particiónX hacia la izquierda\n            high = partitionX - 1;\n        } else {\n            // Necesitamos mover la particiónX hacia la derecha\n            low = partitionX + 1;\n        }\n    }\n} // Variación alternativa",
                "complexity": "Time: O(log(min(M, N))), Space: O(1)",
                "example": {
                    "input": "nums1 = [1, 3], nums2 = [2]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "nums1 = [1, 3], nums2 = [2]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "nums1 = [1, 3], nums2 = [2]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "nums1 = [1, 3], nums2 = [2]",
                                "result": "2.0"
                            },
                            "code_line": "return resultado",
                            "output": "2.0"
                        }
                    ],
                    "final_output": "2.0"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function findMedianSortedArrays(nums1, nums2) {\n    // Aseguramos que nums1 sea el array más pequeño para O(log(min(m,n)))\n    if (nums1.length > nums2.length) {\n        return findMedianSortedArrays(nums2, nums1);\n    }\n    \n    const x = nums1.length;\n    const y = nums2.length;\n    let low = 0;\n    let high = x;\n    \n    while (low <= high) {\n        const partitionX = Math.floor((low + high) / 2);\n        // (x + y + 1) para manejar ambos casos de longitud par e impar\n        const partitionY = Math.floor((x + y + 1) / 2) - partitionX;\n        \n        // Determinar maxLeft y minRight para las cuatro esquinas de las particiones\n        const maxX = (partitionX === 0) ? -Infinity : nums1[partitionX - 1];\n        const minX = (partitionX === x) ? Infinity : nums1[partitionX];\n        \n        const maxY = (partitionY === 0) ? -Infinity : nums2[partitionY - 1];\n        const minY = (partitionY === y) ? Infinity : nums2[partitionY];\n        \n        if (maxX <= minY && maxY <= minX) {\n            // Partición correcta encontrada\n            if ((x + y) % 2 === 0) {\n                // Caso par\n                return (Math.max(maxX, maxY) + Math.min(minX, minY)) / 2;\n            } else {\n                // Caso impar\n                return Math.max(maxX, maxY);\n            }\n        } else if (maxX > minY) {\n            // Necesitamos mover la particiónX hacia la izquierda\n            high = partitionX - 1;\n        } else {\n            // Necesitamos mover la particiónX hacia la derecha\n            low = partitionX + 1;\n        }\n    }\n} // Variación alternativa",
                "complexity": "Time: O(log(min(M, N))), Space: O(1)",
                "example": {
                    "input": "nums1 = [1, 3], nums2 = [2]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "nums1 = [1, 3], nums2 = [2]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "nums1 = [1, 3], nums2 = [2]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "nums1 = [1, 3], nums2 = [2]",
                                "result": "2.0"
                            },
                            "code_line": "return resultado",
                            "output": "2.0"
                        }
                    ],
                    "final_output": "2.0"
                }
            }
        ]
    },
    {
        "id": "longest-palindromic-substring",
        "title": "005. Longest Palindromic Substring",
        "difficulty": "Medium",
        "description": "Dada una cadena `s`, devuelve la subcadena palíndroma más larga en `s`.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Expand Around Center",
                "explanation": "Un palíndromo siempre se expande desde su centro. Hay dos tipos de centros: un carácter único (ej: 'aba', centro 'b') o dos caracteres idénticos (ej: 'abba', centro 'bb'). Iteramos a través de la cadena y, para cada índice, consideramos que ese índice es el centro de un posible palíndromo (tanto impar como par). La función auxiliar `expand` encuentra la longitud máxima del palíndromo que se puede formar a partir de ese centro.",
                "code_snippet": "function longestPalindrome(s) {\n    if (s.length < 2) return s;\n    let start = 0;\n    let maxLength = 1;\n\n    function expand(l, r) {\n        while (l >= 0 && r < s.length && s[l] === s[r]) {\n            l--;\n            r++;\n        }\n        // La longitud es (r-1) - (l+1) + 1 = r - l - 1\n        const currentLength = r - l - 1;\n        if (currentLength > maxLength) {\n            maxLength = currentLength;\n            start = l + 1;\n        }\n    }\n\n    for (let i = 0; i < s.length; i++) {\n        // Centro impar (ej: 'a b a')\n        expand(i, i);\n        // Centro par (ej: 'a bb a')\n        expand(i, i + 1);\n    }\n\n    return s.substring(start, start + maxLength);\n}",
                "complexity": "Time: O(N^2), Space: O(1)",
                "example": {
                    "input": "\"babad\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "\"babad\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "\"babad\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "\"babad\"",
                                "result": "\"bab\" (o \"aba\")"
                            },
                            "code_line": "return resultado",
                            "output": "\"bab\" (o \"aba\")"
                        }
                    ],
                    "final_output": "\"bab\" (o \"aba\")"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function longestPalindrome(s) {\n    if (s.length < 2) return s;\n    let start = 0;\n    let maxLength = 1;\n\n    function expand(l, r) {\n        while (l >= 0 && r < s.length && s[l] === s[r]) {\n            l--;\n            r++;\n        }\n        // La longitud es (r-1) - (l+1) + 1 = r - l - 1\n        const currentLength = r - l - 1;\n        if (currentLength > maxLength) {\n            maxLength = currentLength;\n            start = l + 1;\n        }\n    }\n\n    for (let i = 0; i < s.length; i++) {\n        // Centro impar (ej: 'a b a')\n        expand(i, i);\n        // Centro par (ej: 'a bb a')\n        expand(i, i + 1);\n    }\n\n    return s.substring(start, start + maxLength);\n} // Variación alternativa",
                "complexity": "Time: O(N^2), Space: O(1)",
                "example": {
                    "input": "\"babad\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "\"babad\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "\"babad\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "\"babad\"",
                                "result": "\"bab\" (o \"aba\")"
                            },
                            "code_line": "return resultado",
                            "output": "\"bab\" (o \"aba\")"
                        }
                    ],
                    "final_output": "\"bab\" (o \"aba\")"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function longestPalindrome(s) {\n    if (s.length < 2) return s;\n    let start = 0;\n    let maxLength = 1;\n\n    function expand(l, r) {\n        while (l >= 0 && r < s.length && s[l] === s[r]) {\n            l--;\n            r++;\n        }\n        // La longitud es (r-1) - (l+1) + 1 = r - l - 1\n        const currentLength = r - l - 1;\n        if (currentLength > maxLength) {\n            maxLength = currentLength;\n            start = l + 1;\n        }\n    }\n\n    for (let i = 0; i < s.length; i++) {\n        // Centro impar (ej: 'a b a')\n        expand(i, i);\n        // Centro par (ej: 'a bb a')\n        expand(i, i + 1);\n    }\n\n    return s.substring(start, start + maxLength);\n} // Variación alternativa",
                "complexity": "Time: O(N^2), Space: O(1)",
                "example": {
                    "input": "\"babad\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "\"babad\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "\"babad\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "\"babad\"",
                                "result": "\"bab\" (o \"aba\")"
                            },
                            "code_line": "return resultado",
                            "output": "\"bab\" (o \"aba\")"
                        }
                    ],
                    "final_output": "\"bab\" (o \"aba\")"
                }
            }
        ]
    },
    {
        "id": "string-to-integer-atoi",
        "title": "008. String to Integer (atoi)",
        "difficulty": "Medium",
        "description": "Implementa la función `atoi(string s)` que convierte una cadena en un entero de 32 bits con signo. La función debe ignorar espacios en blanco, manejar signos opcionales y truncar el número si excede el rango de 32 bits.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Parsing de Estado Finito",
                "explanation": "Simulamos el proceso de lectura de un entero con varios pasos (o estados): 1. Saltar espacios en blanco. 2. Determinar el signo (+/-). 3. Leer dígitos hasta encontrar un no-dígito. 4. Aplicar límites de 32 bits (Int32_MAX = 2147483647, Int32_MIN = -2147483648). Si en cualquier momento el `result` excede los límites, se debe truncar inmediatamente.",
                "code_snippet": "function myAtoi(s) {\n    s = s.trim();\n    if (s.length === 0) return 0;\n    \n    let sign = 1;\n    let i = 0;\n    const MAX = 2147483647;\n    const MIN = -2147483648;\n\n    // 1. Manejar el signo\n    if (s[i] === '-') {\n        sign = -1;\n        i++;\n    } else if (s[i] === '+') {\n        i++;\n    }\n\n    let result = 0;\n    \n    // 2. Leer dígitos\n    while (i < s.length && s[i] >= '0' && s[i] <= '9') {\n        const digit = s.charCodeAt(i) - '0'.charCodeAt(0);\n        \n        // Comprobación de desbordamiento ANTES de multiplicar\n        if (sign === 1 && (result > Math.floor(MAX / 10) || (result === Math.floor(MAX / 10) && digit > 7))) {\n            return MAX;\n        }\n        if (sign === -1 && (result > Math.floor(MAX / 10) || (result === Math.floor(MAX / 10) && digit > 8))) {\n            return MIN;\n        }\n\n        result = result * 10 + digit;\n        i++;\n    }\n    \n    return result * sign;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "\"-42\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "\"-42\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "\"-42\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "\"-42\"",
                                "result": "-42"
                            },
                            "code_line": "return resultado",
                            "output": "-42"
                        }
                    ],
                    "final_output": "-42"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function myAtoi(s) {\n    s = s.trim();\n    if (s.length === 0) return 0;\n    \n    let sign = 1;\n    let i = 0;\n    const MAX = 2147483647;\n    const MIN = -2147483648;\n\n    // 1. Manejar el signo\n    if (s[i] === '-') {\n        sign = -1;\n        i++;\n    } else if (s[i] === '+') {\n        i++;\n    }\n\n    let result = 0;\n    \n    // 2. Leer dígitos\n    while (i < s.length && s[i] >= '0' && s[i] <= '9') {\n        const digit = s.charCodeAt(i) - '0'.charCodeAt(0);\n        \n        // Comprobación de desbordamiento ANTES de multiplicar\n        if (sign === 1 && (result > Math.floor(MAX / 10) || (result === Math.floor(MAX / 10) && digit > 7))) {\n            return MAX;\n        }\n        if (sign === -1 && (result > Math.floor(MAX / 10) || (result === Math.floor(MAX / 10) && digit > 8))) {\n            return MIN;\n        }\n\n        result = result * 10 + digit;\n        i++;\n    }\n    \n    return result * sign;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "\"-42\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "\"-42\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "\"-42\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "\"-42\"",
                                "result": "-42"
                            },
                            "code_line": "return resultado",
                            "output": "-42"
                        }
                    ],
                    "final_output": "-42"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function myAtoi(s) {\n    s = s.trim();\n    if (s.length === 0) return 0;\n    \n    let sign = 1;\n    let i = 0;\n    const MAX = 2147483647;\n    const MIN = -2147483648;\n\n    // 1. Manejar el signo\n    if (s[i] === '-') {\n        sign = -1;\n        i++;\n    } else if (s[i] === '+') {\n        i++;\n    }\n\n    let result = 0;\n    \n    // 2. Leer dígitos\n    while (i < s.length && s[i] >= '0' && s[i] <= '9') {\n        const digit = s.charCodeAt(i) - '0'.charCodeAt(0);\n        \n        // Comprobación de desbordamiento ANTES de multiplicar\n        if (sign === 1 && (result > Math.floor(MAX / 10) || (result === Math.floor(MAX / 10) && digit > 7))) {\n            return MAX;\n        }\n        if (sign === -1 && (result > Math.floor(MAX / 10) || (result === Math.floor(MAX / 10) && digit > 8))) {\n            return MIN;\n        }\n\n        result = result * 10 + digit;\n        i++;\n    }\n    \n    return result * sign;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "\"-42\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "\"-42\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "\"-42\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "\"-42\"",
                                "result": "-42"
                            },
                            "code_line": "return resultado",
                            "output": "-42"
                        }
                    ],
                    "final_output": "-42"
                }
            }
        ]
    },
    {
        "id": "remove-element",
        "title": "027. Remove Element",
        "difficulty": "Easy",
        "description": "Dado un array `nums` y un valor `val`, elimina todas las ocurrencias de ese valor *in place* y devuelve la nueva longitud del array.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Two Pointers (Puntero de Escrito)",
                "explanation": "Similar a 'Remove Duplicates', usamos un puntero de 'escritura' (`k`) que solo avanza cuando encontramos un elemento que *no* es el valor a remover (`val`). Iteramos con un puntero rápido (`i`). Si `nums[i]` no es igual a `val`, lo copiamos a la posición `nums[k]` y avanzamos `k`. Si `nums[i]` es igual a `val`, simplemente avanzamos `i`, dejando el valor en su lugar (se sobrescribirá más tarde).",
                "code_snippet": "function removeElement(nums, val) {\n    let k = 0; // Índice para la colocación de elementos que no son 'val'\n    \n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== val) {\n            // Mover el elemento no deseado a la posición de escritura\n            nums[k] = nums[i];\n            k++;\n        }\n    }\n    // k es la nueva longitud\n    return k;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[3, 2, 2, 3], val = 3",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[3, 2, 2, 3], val = 3"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[3, 2, 2, 3], val = 3",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[3, 2, 2, 3], val = 3",
                                "result": "2, nums modificado a [2, 2, _, _]"
                            },
                            "code_line": "return resultado",
                            "output": "2, nums modificado a [2, 2, _, _]"
                        }
                    ],
                    "final_output": "2, nums modificado a [2, 2, _, _]"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function removeElement(nums, val) {\n    let k = 0; // Índice para la colocación de elementos que no son 'val'\n    \n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== val) {\n            // Mover el elemento no deseado a la posición de escritura\n            nums[k] = nums[i];\n            k++;\n        }\n    }\n    // k es la nueva longitud\n    return k;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[3, 2, 2, 3], val = 3",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[3, 2, 2, 3], val = 3"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[3, 2, 2, 3], val = 3",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[3, 2, 2, 3], val = 3",
                                "result": "2, nums modificado a [2, 2, _, _]"
                            },
                            "code_line": "return resultado",
                            "output": "2, nums modificado a [2, 2, _, _]"
                        }
                    ],
                    "final_output": "2, nums modificado a [2, 2, _, _]"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function removeElement(nums, val) {\n    let k = 0; // Índice para la colocación de elementos que no son 'val'\n    \n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] !== val) {\n            // Mover el elemento no deseado a la posición de escritura\n            nums[k] = nums[i];\n            k++;\n        }\n    }\n    // k es la nueva longitud\n    return k;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[3, 2, 2, 3], val = 3",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[3, 2, 2, 3], val = 3"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[3, 2, 2, 3], val = 3",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[3, 2, 2, 3], val = 3",
                                "result": "2, nums modificado a [2, 2, _, _]"
                            },
                            "code_line": "return resultado",
                            "output": "2, nums modificado a [2, 2, _, _]"
                        }
                    ],
                    "final_output": "2, nums modificado a [2, 2, _, _]"
                }
            }
        ]
    },
    {
        "id": "divide-two-integers",
        "title": "029. Divide Two Integers",
        "difficulty": "Medium",
        "description": "Dados dos enteros, `dividend` y `divisor`, divídelos sin usar los operadores de multiplicación, división o módulo. El resultado debe ser truncado hacia cero y limitado al rango de enteros de 32 bits.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Sustracción Repetida Optimizada (Bit Manipulation)",
                "explanation": "La división es una sustracción repetida. Para optimizar, en lugar de restar el divisor una y otra vez, restamos múltiplos del divisor que crecen exponencialmente (divisor * 2, divisor * 4, divisor * 8, etc.) usando el desplazamiento de bits (`<<`). Esto permite reducir el tiempo de O(N) a O(log N). El problema se maneja mejor en valores absolutos para simplificar la lógica de sustracción, aplicando el signo al final y manejando el caso especial de desbordamiento.",
                "code_snippet": "function divide(dividend, divisor) {\n    const MAX = 2147483647;\n    const MIN = -2147483648;\n\n    if (dividend === MIN && divisor === -1) return MAX; // Caso de desbordamiento especial\n\n    const isNegative = (dividend < 0) !== (divisor < 0);\n\n    // Usar valores absolutos (convertidos a positivos largos para evitar desbordamiento antes de tiempo)\n    let absDividend = Math.abs(dividend);\n    let absDivisor = Math.abs(divisor);\n    let quotient = 0;\n\n    while (absDividend >= absDivisor) {\n        let tempDivisor = absDivisor;\n        let multiple = 1;\n        \n        // Encontrar el mayor múltiplo de divisor que cabe en absDividend\n        while (absDividend >= (tempDivisor << 1)) {\n            tempDivisor <<= 1; // Duplicar el divisor\n            multiple <<= 1;    // Duplicar el cociente (2, 4, 8, ...)\n        }\n        \n        absDividend -= tempDivisor;\n        quotient += multiple;\n    }\n\n    const result = isNegative ? -quotient : quotient;\n    return Math.max(MIN, Math.min(MAX, result));\n}",
                "complexity": "Time: O(log N), Space: O(1)",
                "example": {
                    "input": "dividend = 10, divisor = 3",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "dividend = 10, divisor = 3"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "dividend = 10, divisor = 3",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "dividend = 10, divisor = 3",
                                "result": "3"
                            },
                            "code_line": "return resultado",
                            "output": "3"
                        }
                    ],
                    "final_output": "3"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function divide(dividend, divisor) {\n    const MAX = 2147483647;\n    const MIN = -2147483648;\n\n    if (dividend === MIN && divisor === -1) return MAX; // Caso de desbordamiento especial\n\n    const isNegative = (dividend < 0) !== (divisor < 0);\n\n    // Usar valores absolutos (convertidos a positivos largos para evitar desbordamiento antes de tiempo)\n    let absDividend = Math.abs(dividend);\n    let absDivisor = Math.abs(divisor);\n    let quotient = 0;\n\n    while (absDividend >= absDivisor) {\n        let tempDivisor = absDivisor;\n        let multiple = 1;\n        \n        // Encontrar el mayor múltiplo de divisor que cabe en absDividend\n        while (absDividend >= (tempDivisor << 1)) {\n            tempDivisor <<= 1; // Duplicar el divisor\n            multiple <<= 1;    // Duplicar el cociente (2, 4, 8, ...)\n        }\n        \n        absDividend -= tempDivisor;\n        quotient += multiple;\n    }\n\n    const result = isNegative ? -quotient : quotient;\n    return Math.max(MIN, Math.min(MAX, result));\n} // Variación alternativa",
                "complexity": "Time: O(log N), Space: O(1)",
                "example": {
                    "input": "dividend = 10, divisor = 3",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "dividend = 10, divisor = 3"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "dividend = 10, divisor = 3",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "dividend = 10, divisor = 3",
                                "result": "3"
                            },
                            "code_line": "return resultado",
                            "output": "3"
                        }
                    ],
                    "final_output": "3"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function divide(dividend, divisor) {\n    const MAX = 2147483647;\n    const MIN = -2147483648;\n\n    if (dividend === MIN && divisor === -1) return MAX; // Caso de desbordamiento especial\n\n    const isNegative = (dividend < 0) !== (divisor < 0);\n\n    // Usar valores absolutos (convertidos a positivos largos para evitar desbordamiento antes de tiempo)\n    let absDividend = Math.abs(dividend);\n    let absDivisor = Math.abs(divisor);\n    let quotient = 0;\n\n    while (absDividend >= absDivisor) {\n        let tempDivisor = absDivisor;\n        let multiple = 1;\n        \n        // Encontrar el mayor múltiplo de divisor que cabe en absDividend\n        while (absDividend >= (tempDivisor << 1)) {\n            tempDivisor <<= 1; // Duplicar el divisor\n            multiple <<= 1;    // Duplicar el cociente (2, 4, 8, ...)\n        }\n        \n        absDividend -= tempDivisor;\n        quotient += multiple;\n    }\n\n    const result = isNegative ? -quotient : quotient;\n    return Math.max(MIN, Math.min(MAX, result));\n} // Variación alternativa",
                "complexity": "Time: O(log N), Space: O(1)",
                "example": {
                    "input": "dividend = 10, divisor = 3",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "dividend = 10, divisor = 3"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "dividend = 10, divisor = 3",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "dividend = 10, divisor = 3",
                                "result": "3"
                            },
                            "code_line": "return resultado",
                            "output": "3"
                        }
                    ],
                    "final_output": "3"
                }
            }
        ]
    },
    {
        "id": "rotate-array",
        "title": "189. Rotate Array",
        "difficulty": "Medium",
        "description": "Dado un array, rota el array hacia la derecha por `k` pasos. La rotación debe ser *in place*.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Reversa de Tres Pasos",
                "explanation": "La solución más eficiente *in place* con O(1) de espacio es la reversa triple. Se basa en la observación de que rotar un array es equivalente a revertir las dos subsecciones de la partición de rotación. 1. Revertir todo el array. 2. Revertir los primeros `k` elementos. 3. Revertir los elementos restantes (N-k). Primero, se calcula $k = k \\pmod{N}$ para manejar rotaciones mayores que la longitud del array.",
                "code_snippet": "function rotate(nums, k) {\n    const n = nums.length;\n    k = k % n; // Manejar k > n\n    \n    // Función auxiliar para revertir una subsección del array\n    const reverse = (arr, start, end) => {\n        while (start < end) {\n            [arr[start], arr[end]] = [arr[end], arr[start]];\n            start++;\n            end--;\n        }\n    };\n    \n    // 1. Revertir todo el array\n    reverse(nums, 0, n - 1);\n    \n    // 2. Revertir los primeros k elementos (que ahora son los últimos k)\n    reverse(nums, 0, k - 1);\n    \n    // 3. Revertir los n-k elementos restantes\n    reverse(nums, k, n - 1);\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[1, 2, 3, 4, 5, 6, 7], k = 3",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[1, 2, 3, 4, 5, 6, 7], k = 3"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[1, 2, 3, 4, 5, 6, 7], k = 3",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[1, 2, 3, 4, 5, 6, 7], k = 3",
                                "result": "[5, 6, 7, 1, 2, 3, 4]"
                            },
                            "code_line": "return resultado",
                            "output": "[5, 6, 7, 1, 2, 3, 4]"
                        }
                    ],
                    "final_output": "[5, 6, 7, 1, 2, 3, 4]"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function rotate(nums, k) {\n    const n = nums.length;\n    k = k % n; // Manejar k > n\n    \n    // Función auxiliar para revertir una subsección del array\n    const reverse = (arr, start, end) => {\n        while (start < end) {\n            [arr[start], arr[end]] = [arr[end], arr[start]];\n            start++;\n            end--;\n        }\n    };\n    \n    // 1. Revertir todo el array\n    reverse(nums, 0, n - 1);\n    \n    // 2. Revertir los primeros k elementos (que ahora son los últimos k)\n    reverse(nums, 0, k - 1);\n    \n    // 3. Revertir los n-k elementos restantes\n    reverse(nums, k, n - 1);\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[1, 2, 3, 4, 5, 6, 7], k = 3",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[1, 2, 3, 4, 5, 6, 7], k = 3"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[1, 2, 3, 4, 5, 6, 7], k = 3",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[1, 2, 3, 4, 5, 6, 7], k = 3",
                                "result": "[5, 6, 7, 1, 2, 3, 4]"
                            },
                            "code_line": "return resultado",
                            "output": "[5, 6, 7, 1, 2, 3, 4]"
                        }
                    ],
                    "final_output": "[5, 6, 7, 1, 2, 3, 4]"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function rotate(nums, k) {\n    const n = nums.length;\n    k = k % n; // Manejar k > n\n    \n    // Función auxiliar para revertir una subsección del array\n    const reverse = (arr, start, end) => {\n        while (start < end) {\n            [arr[start], arr[end]] = [arr[end], arr[start]];\n            start++;\n            end--;\n        }\n    };\n    \n    // 1. Revertir todo el array\n    reverse(nums, 0, n - 1);\n    \n    // 2. Revertir los primeros k elementos (que ahora son los últimos k)\n    reverse(nums, 0, k - 1);\n    \n    // 3. Revertir los n-k elementos restantes\n    reverse(nums, k, n - 1);\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[1, 2, 3, 4, 5, 6, 7], k = 3",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[1, 2, 3, 4, 5, 6, 7], k = 3"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[1, 2, 3, 4, 5, 6, 7], k = 3",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[1, 2, 3, 4, 5, 6, 7], k = 3",
                                "result": "[5, 6, 7, 1, 2, 3, 4]"
                            },
                            "code_line": "return resultado",
                            "output": "[5, 6, 7, 1, 2, 3, 4]"
                        }
                    ],
                    "final_output": "[5, 6, 7, 1, 2, 3, 4]"
                }
            }
        ]
    },
    {
        "id": "majority-element",
        "title": "169. Majority Element",
        "difficulty": "Easy",
        "description": "Dado un array de tamaño `n`, encuentra el elemento mayoritario. El elemento mayoritario es el elemento que aparece más de $\\lfloor n/2 \\rfloor$ veces. Puedes asumir que el array no es vacío y el elemento mayoritario siempre existe.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Algoritmo de Boyer-Moore Voting",
                "explanation": "Este algoritmo es sorprendentemente simple y funciona en O(N) con O(1) de espacio. Se basa en la idea de que si contamos un elemento como 'candidato' y encontramos otro diferente, 'cancelamos' su cuenta. Dado que el elemento mayoritario aparece más de la mitad de las veces, su cuenta nunca será 0 al final. Inicializamos un `count` a 0 y un `candidate`. Por cada número, si `count` es 0, establecemos el número actual como el nuevo candidato. Si el número coincide con el candidato, incrementamos `count`; si no, lo decrementamos.",
                "code_snippet": "function majorityElement(nums) {\n    let candidate = 0;\n    let count = 0;\n    \n    for (const num of nums) {\n        if (count === 0) {\n            candidate = num;\n        }\n        \n        if (num === candidate) {\n            count++;\n        } else {\n            count--;\n        }\n    }\n    return candidate;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[2, 2, 1, 1, 1, 2, 2]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[2, 2, 1, 1, 1, 2, 2]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[2, 2, 1, 1, 1, 2, 2]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[2, 2, 1, 1, 1, 2, 2]",
                                "result": "2"
                            },
                            "code_line": "return resultado",
                            "output": "2"
                        }
                    ],
                    "final_output": "2"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function majorityElement(nums) {\n    let candidate = 0;\n    let count = 0;\n    \n    for (const num of nums) {\n        if (count === 0) {\n            candidate = num;\n        }\n        \n        if (num === candidate) {\n            count++;\n        } else {\n            count--;\n        }\n    }\n    return candidate;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[2, 2, 1, 1, 1, 2, 2]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[2, 2, 1, 1, 1, 2, 2]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[2, 2, 1, 1, 1, 2, 2]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[2, 2, 1, 1, 1, 2, 2]",
                                "result": "2"
                            },
                            "code_line": "return resultado",
                            "output": "2"
                        }
                    ],
                    "final_output": "2"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function majorityElement(nums) {\n    let candidate = 0;\n    let count = 0;\n    \n    for (const num of nums) {\n        if (count === 0) {\n            candidate = num;\n        }\n        \n        if (num === candidate) {\n            count++;\n        } else {\n            count--;\n        }\n    }\n    return candidate;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[2, 2, 1, 1, 1, 2, 2]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[2, 2, 1, 1, 1, 2, 2]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[2, 2, 1, 1, 1, 2, 2]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[2, 2, 1, 1, 1, 2, 2]",
                                "result": "2"
                            },
                            "code_line": "return resultado",
                            "output": "2"
                        }
                    ],
                    "final_output": "2"
                }
            }
        ]
    },
    {
        "id": "implement-queue-using-stacks",
        "title": "232. Implement Queue using Stacks",
        "difficulty": "Easy",
        "description": "Implementa una cola FIFO (First-In, First-Out) usando solo dos pilas LIFO (Last-In, First-Out).",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Dos Pilas con Movimiento Perezoso (Lazy Transfer)",
                "explanation": "Utilizamos dos pilas: `inputStack` (para `push`) y `outputStack` (para `pop`/`peek`). Los elementos se empujan primero en `inputStack`. Cuando se solicita una operación `pop` o `peek`, si `outputStack` está vacía, movemos **todos** los elementos de `inputStack` a `outputStack`. Esta transferencia invierte el orden, convirtiendo la operación LIFO de `inputStack` en FIFO en `outputStack`. Esta transferencia es amortizada O(1).",
                "code_snippet": "class MyQueue {\n    constructor() {\n        this.inputStack = [];\n        this.outputStack = [];\n    }\n\n    // Mueve elementos de input a output, invirtiendo el orden\n    transfer() {\n        if (this.outputStack.length === 0) {\n            while (this.inputStack.length > 0) {\n                this.outputStack.push(this.inputStack.pop());\n            }\n        }\n    }\n\n    push(x) {\n        this.inputStack.push(x);\n    }\n\n    pop() {\n        this.transfer();\n        return this.outputStack.pop();\n    }\n\n    peek() {\n        this.transfer();\n        return this.outputStack[this.outputStack.length - 1];\n    }\n\n    empty() {\n        return this.inputStack.length === 0 && this.outputStack.length === 0;\n    }\n}",
                "complexity": "Time: O(1) amortizado para todas las operaciones. O(N) en el peor caso de transferencia.",
                "example": "push(1), push(2), peek() -> 1, pop() -> 1"
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "class MyQueue {\n    constructor() {\n        this.inputStack = [];\n        this.outputStack = [];\n    }\n\n    // Mueve elementos de input a output, invirtiendo el orden\n    transfer() {\n        if (this.outputStack.length === 0) {\n            while (this.inputStack.length > 0) {\n                this.outputStack.push(this.inputStack.pop());\n            }\n        }\n    }\n\n    push(x) {\n        this.inputStack.push(x);\n    }\n\n    pop() {\n        this.transfer();\n        return this.outputStack.pop();\n    }\n\n    peek() {\n        this.transfer();\n        return this.outputStack[this.outputStack.length - 1];\n    }\n\n    empty() {\n        return this.inputStack.length === 0 && this.outputStack.length === 0;\n    }\n} // Variación alternativa",
                "complexity": "Time: O(1) amortizado para todas las operaciones. O(N) en el peor caso de transferencia.",
                "example": "push(1), push(2), peek() -> 1, pop() -> 1"
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "class MyQueue {\n    constructor() {\n        this.inputStack = [];\n        this.outputStack = [];\n    }\n\n    // Mueve elementos de input a output, invirtiendo el orden\n    transfer() {\n        if (this.outputStack.length === 0) {\n            while (this.inputStack.length > 0) {\n                this.outputStack.push(this.inputStack.pop());\n            }\n        }\n    }\n\n    push(x) {\n        this.inputStack.push(x);\n    }\n\n    pop() {\n        this.transfer();\n        return this.outputStack.pop();\n    }\n\n    peek() {\n        this.transfer();\n        return this.outputStack[this.outputStack.length - 1];\n    }\n\n    empty() {\n        return this.inputStack.length === 0 && this.outputStack.length === 0;\n    }\n} // Variación alternativa",
                "complexity": "Time: O(1) amortizado para todas las operaciones. O(N) en el peor caso de transferencia.",
                "example": "push(1), push(2), peek() -> 1, pop() -> 1"
            }
        ]
    },
    {
        "id": "intersection-of-two-arrays-ii",
        "title": "350. Intersection of Two Arrays II",
        "difficulty": "Easy",
        "description": "Dados dos arrays, `nums1` y `nums2`, devuelve su intersección. Cada elemento en el resultado debe aparecer tantas veces como lo haga en ambos arrays. El resultado puede estar en cualquier orden.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Hash Map (Contador de Frecuencia)",
                "explanation": "Para garantizar que se respete la frecuencia de los elementos (a diferencia de un Set que solo verifica la existencia), usamos un Hash Map para contar las frecuencias de los elementos en el array más pequeño. Luego, iteramos sobre el segundo array. Si un elemento existe en el mapa y su conteo es mayor que cero, lo agregamos al resultado y decrementamos su conteo en el mapa.",
                "code_snippet": "function intersect(nums1, nums2) {\n    // Usar el array más pequeño para construir el mapa, optimizando espacio\n    if (nums1.length > nums2.length) {\n        return intersect(nums2, nums1);\n    }\n\n    const map = new Map();\n    for (const num of nums1) {\n        map.set(num, (map.get(num) || 0) + 1);\n    }\n\n    const result = [];\n    for (const num of nums2) {\n        const count = map.get(num);\n        if (count && count > 0) {\n            result.push(num);\n            map.set(num, count - 1); // Decrementar el conteo para no usarlo de nuevo\n        }\n    }\n    return result;\n}",
                "complexity": "Time: O(N + M), Space: O(min(N, M))",
                "example": {
                    "input": "nums1 = [1, 2, 2, 1], nums2 = [2, 2]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "nums1 = [1, 2, 2, 1], nums2 = [2, 2]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "nums1 = [1, 2, 2, 1], nums2 = [2, 2]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "nums1 = [1, 2, 2, 1], nums2 = [2, 2]",
                                "result": "[2, 2]"
                            },
                            "code_line": "return resultado",
                            "output": "[2, 2]"
                        }
                    ],
                    "final_output": "[2, 2]"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function intersect(nums1, nums2) {\n    // Usar el array más pequeño para construir el mapa, optimizando espacio\n    if (nums1.length > nums2.length) {\n        return intersect(nums2, nums1);\n    }\n\n    const map = new Map();\n    for (const num of nums1) {\n        map.set(num, (map.get(num) || 0) + 1);\n    }\n\n    const result = [];\n    for (const num of nums2) {\n        const count = map.get(num);\n        if (count && count > 0) {\n            result.push(num);\n            map.set(num, count - 1); // Decrementar el conteo para no usarlo de nuevo\n        }\n    }\n    return result;\n} // Variación alternativa",
                "complexity": "Time: O(N + M), Space: O(min(N, M))",
                "example": {
                    "input": "nums1 = [1, 2, 2, 1], nums2 = [2, 2]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "nums1 = [1, 2, 2, 1], nums2 = [2, 2]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "nums1 = [1, 2, 2, 1], nums2 = [2, 2]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "nums1 = [1, 2, 2, 1], nums2 = [2, 2]",
                                "result": "[2, 2]"
                            },
                            "code_line": "return resultado",
                            "output": "[2, 2]"
                        }
                    ],
                    "final_output": "[2, 2]"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function intersect(nums1, nums2) {\n    // Usar el array más pequeño para construir el mapa, optimizando espacio\n    if (nums1.length > nums2.length) {\n        return intersect(nums2, nums1);\n    }\n\n    const map = new Map();\n    for (const num of nums1) {\n        map.set(num, (map.get(num) || 0) + 1);\n    }\n\n    const result = [];\n    for (const num of nums2) {\n        const count = map.get(num);\n        if (count && count > 0) {\n            result.push(num);\n            map.set(num, count - 1); // Decrementar el conteo para no usarlo de nuevo\n        }\n    }\n    return result;\n} // Variación alternativa",
                "complexity": "Time: O(N + M), Space: O(min(N, M))",
                "example": {
                    "input": "nums1 = [1, 2, 2, 1], nums2 = [2, 2]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "nums1 = [1, 2, 2, 1], nums2 = [2, 2]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "nums1 = [1, 2, 2, 1], nums2 = [2, 2]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "nums1 = [1, 2, 2, 1], nums2 = [2, 2]",
                                "result": "[2, 2]"
                            },
                            "code_line": "return resultado",
                            "output": "[2, 2]"
                        }
                    ],
                    "final_output": "[2, 2]"
                }
            }
        ]
    },
    {
        "id": "ransom-note",
        "title": "383. Ransom Note",
        "difficulty": "Easy",
        "description": "Dadas dos cadenas, `ransomNote` y `magazine`, devuelve `true` si `ransomNote` se puede construir usando las letras de `magazine`; de lo contrario, devuelve `false`. Cada letra en `magazine` solo se puede usar una vez.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Contadores de Frecuencia (Array/Map)",
                "explanation": "Este es un problema de conteo de frecuencia. Primero, contamos la ocurrencia de cada carácter en la `magazine`. Luego, iteramos a través de la `ransomNote`. Por cada carácter necesario, verificamos si su conteo en la `magazine` es mayor que cero. Si lo es, decrementamos el conteo; si no, significa que la revista no tiene suficientes letras, y devolvemos `false` inmediatamente.",
                "code_snippet": "function canConstruct(ransomNote, magazine) {\n    const counts = new Array(26).fill(0);\n    \n    // Paso 1: Contar las letras en la magazine\n    for (const char of magazine) {\n        const index = char.charCodeAt(0) - 'a'.charCodeAt(0);\n        counts[index]++;\n    }\n    \n    // Paso 2: Verificar si la ransomNote se puede construir\n    for (const char of ransomNote) {\n        const index = char.charCodeAt(0) - 'a'.charCodeAt(0);\n        if (counts[index] > 0) {\n            counts[index]--;\n        } else {\n            return false; // No hay suficientes letras disponibles\n        }\n    }\n    \n    return true;\n}",
                "complexity": "Time: O(M + N), donde M es la longitud de magazine y N es la longitud de ransomNote. Space: O(1) (porque el array de conteo es de tamaño 26).",
                "example": {
                    "input": "ransomNote = \"aa\", magazine = \"ab\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "ransomNote = \"aa\", magazine = \"ab\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "ransomNote = \"aa\", magazine = \"ab\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "ransomNote = \"aa\", magazine = \"ab\"",
                                "result": "false"
                            },
                            "code_line": "return resultado",
                            "output": "false"
                        }
                    ],
                    "final_output": "false"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function canConstruct(ransomNote, magazine) {\n    const counts = new Array(26).fill(0);\n    \n    // Paso 1: Contar las letras en la magazine\n    for (const char of magazine) {\n        const index = char.charCodeAt(0) - 'a'.charCodeAt(0);\n        counts[index]++;\n    }\n    \n    // Paso 2: Verificar si la ransomNote se puede construir\n    for (const char of ransomNote) {\n        const index = char.charCodeAt(0) - 'a'.charCodeAt(0);\n        if (counts[index] > 0) {\n            counts[index]--;\n        } else {\n            return false; // No hay suficientes letras disponibles\n        }\n    }\n    \n    return true;\n} // Variación alternativa",
                "complexity": "Time: O(M + N), donde M es la longitud de magazine y N es la longitud de ransomNote. Space: O(1) (porque el array de conteo es de tamaño 26).",
                "example": {
                    "input": "ransomNote = \"aa\", magazine = \"ab\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "ransomNote = \"aa\", magazine = \"ab\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "ransomNote = \"aa\", magazine = \"ab\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "ransomNote = \"aa\", magazine = \"ab\"",
                                "result": "false"
                            },
                            "code_line": "return resultado",
                            "output": "false"
                        }
                    ],
                    "final_output": "false"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function canConstruct(ransomNote, magazine) {\n    const counts = new Array(26).fill(0);\n    \n    // Paso 1: Contar las letras en la magazine\n    for (const char of magazine) {\n        const index = char.charCodeAt(0) - 'a'.charCodeAt(0);\n        counts[index]++;\n    }\n    \n    // Paso 2: Verificar si la ransomNote se puede construir\n    for (const char of ransomNote) {\n        const index = char.charCodeAt(0) - 'a'.charCodeAt(0);\n        if (counts[index] > 0) {\n            counts[index]--;\n        } else {\n            return false; // No hay suficientes letras disponibles\n        }\n    }\n    \n    return true;\n} // Variación alternativa",
                "complexity": "Time: O(M + N), donde M es la longitud de magazine y N es la longitud de ransomNote. Space: O(1) (porque el array de conteo es de tamaño 26).",
                "example": {
                    "input": "ransomNote = \"aa\", magazine = \"ab\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "ransomNote = \"aa\", magazine = \"ab\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "ransomNote = \"aa\", magazine = \"ab\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "ransomNote = \"aa\", magazine = \"ab\"",
                                "result": "false"
                            },
                            "code_line": "return resultado",
                            "output": "false"
                        }
                    ],
                    "final_output": "false"
                }
            }
        ]
    },
    {
        "id": "first-unique-character-in-a-string",
        "title": "387. First Unique Character in a String",
        "difficulty": "Easy",
        "description": "Dada una cadena `s`, encuentra el primer carácter no repetido en ella y devuelve su índice. Si no existe, devuelve -1.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Dos Pasadas con Hash Map/Array",
                "explanation": "El desafío es encontrar el *primer* único. No podemos hacerlo en una sola pasada porque no sabemos si un carácter se repetirá más tarde. 1. Primera pasada: Usamos un mapa (o un array de tamaño 26 si solo son minúsculas) para contar la frecuencia de cada carácter. 2. Segunda pasada: Iteramos sobre la cadena *original*. Para cada carácter, consultamos su conteo. Si el conteo es 1, hemos encontrado el primer carácter no repetido y devolvemos su índice.",
                "code_snippet": "function firstUniqChar(s) {\n    const charCounts = new Map();\n    \n    // Paso 1: Contar la frecuencia de cada caracter\n    for (const char of s) {\n        charCounts.set(char, (charCounts.get(char) || 0) + 1);\n    }\n    \n    // Paso 2: Buscar el primer caracter con conteo 1\n    for (let i = 0; i < s.length; i++) {\n        if (charCounts.get(s[i]) === 1) {\n            return i;\n        }\n    }\n    \n    return -1;\n}",
                "complexity": "Time: O(N) (dos pasadas), Space: O(1) o O(AlphabetSize)",
                "example": {
                    "input": "\"leetcode\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "\"leetcode\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "\"leetcode\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "\"leetcode\"",
                                "result": "0"
                            },
                            "code_line": "return resultado",
                            "output": "0"
                        }
                    ],
                    "final_output": "0"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function firstUniqChar(s) {\n    const charCounts = new Map();\n    \n    // Paso 1: Contar la frecuencia de cada caracter\n    for (const char of s) {\n        charCounts.set(char, (charCounts.get(char) || 0) + 1);\n    }\n    \n    // Paso 2: Buscar el primer caracter con conteo 1\n    for (let i = 0; i < s.length; i++) {\n        if (charCounts.get(s[i]) === 1) {\n            return i;\n        }\n    }\n    \n    return -1;\n} // Variación alternativa",
                "complexity": "Time: O(N) (dos pasadas), Space: O(1) o O(AlphabetSize)",
                "example": {
                    "input": "\"leetcode\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "\"leetcode\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "\"leetcode\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "\"leetcode\"",
                                "result": "0"
                            },
                            "code_line": "return resultado",
                            "output": "0"
                        }
                    ],
                    "final_output": "0"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function firstUniqChar(s) {\n    const charCounts = new Map();\n    \n    // Paso 1: Contar la frecuencia de cada caracter\n    for (const char of s) {\n        charCounts.set(char, (charCounts.get(char) || 0) + 1);\n    }\n    \n    // Paso 2: Buscar el primer caracter con conteo 1\n    for (let i = 0; i < s.length; i++) {\n        if (charCounts.get(s[i]) === 1) {\n            return i;\n        }\n    }\n    \n    return -1;\n} // Variación alternativa",
                "complexity": "Time: O(N) (dos pasadas), Space: O(1) o O(AlphabetSize)",
                "example": {
                    "input": "\"leetcode\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "\"leetcode\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "\"leetcode\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "\"leetcode\"",
                                "result": "0"
                            },
                            "code_line": "return resultado",
                            "output": "0"
                        }
                    ],
                    "final_output": "0"
                }
            }
        ]
    },
    {
        "id": "missing-number",
        "title": "268. Missing Number",
        "difficulty": "Easy",
        "description": "Dado un array `nums` que contiene `n` números distintos en el rango $[0, n]$, devuelve el único número en el rango que está ausente en el array.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Suma de Gauss",
                "explanation": "La suma de los primeros $n$ enteros no negativos (0 a $n$) se puede calcular rápidamente usando la fórmula de Gauss: $\\frac{n(n+1)}{2}$. Si restamos la suma de todos los números en el array `nums` a esta suma esperada, el resultado será el número faltante.",
                "code_snippet": "function missingNumber(nums) {\n    const n = nums.length;\n    // Suma esperada de 0 a n\n    const expectedSum = (n * (n + 1)) / 2;\n    \n    // Suma real de los números en el array\n    let actualSum = 0;\n    for (const num of nums) {\n        actualSum += num;\n    }\n    \n    return expectedSum - actualSum;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[3, 0, 1]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[3, 0, 1]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[3, 0, 1]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[3, 0, 1]",
                                "result": "2"
                            },
                            "code_line": "return resultado",
                            "output": "2"
                        }
                    ],
                    "final_output": "2"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: XOR (Optimal)",
                "explanation": "Podemos usar la propiedad XOR para encontrar el número faltante sin desbordamientos de enteros. Hacemos XOR de todos los números del array (`nums`) con todos los números del rango esperado ($0$ a $n$). Dado que $A \\oplus A = 0$ y $A \\oplus 0 = A$, todos los números presentes en el array se cancelarán con sus contrapartes en el rango, dejando solo el número faltante.",
                "code_snippet": "function missingNumber(nums) {\n    let missing = nums.length; // Inicializar con N, que es parte del rango esperado\n    \n    for (let i = 0; i < nums.length; i++) {\n        // XOR de (índice) ^ (valor)\n        missing ^= i; \n        missing ^= nums[i];\n    }\n    \n    return missing;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[9, 6, 4, 2, 3, 5, 7, 0, 1]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[9, 6, 4, 2, 3, 5, 7, 0, 1]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[9, 6, 4, 2, 3, 5, 7, 0, 1]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[9, 6, 4, 2, 3, 5, 7, 0, 1]",
                                "result": "8"
                            },
                            "code_line": "return resultado",
                            "output": "8"
                        }
                    ],
                    "final_output": "8"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function missingNumber(nums) {\n    const n = nums.length;\n    // Suma esperada de 0 a n\n    const expectedSum = (n * (n + 1)) / 2;\n    \n    // Suma real de los números en el array\n    let actualSum = 0;\n    for (const num of nums) {\n        actualSum += num;\n    }\n    \n    return expectedSum - actualSum;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "[3, 0, 1]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[3, 0, 1]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[3, 0, 1]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[3, 0, 1]",
                                "result": "2"
                            },
                            "code_line": "return resultado",
                            "output": "2"
                        }
                    ],
                    "final_output": "2"
                }
            }
        ]
    },
    {
        "id": "power-of-two",
        "title": "231. Power of Two",
        "difficulty": "Easy",
        "description": "Dada un entero `n`, devuelve `true` si es una potencia de dos. En otras palabras, devuelve `true` si existe un entero `x` tal que $n = 2^x$.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Propiedad de Manipulación de Bits (Bitwise)",
                "explanation": "Una propiedad fundamental de las potencias de dos en binario es que solo tienen un bit establecido (ej: $1 = 0001, 2 = 0010, 4 = 0100$). Si restamos 1 a una potencia de dos, todos los bits a la derecha del bit establecido se vuelven 1, y el bit establecido se vuelve 0 (ej: $4-1 = 3$, $0100 \\to 0011$). Por lo tanto, el AND bitwise (`&`) entre un número que es potencia de dos (`n`) y (`n-1`) siempre resultará en 0, es decir: $n \\& (n-1) = 0$. Debemos asegurarnos de que $n > 0$.",
                "code_snippet": "function isPowerOfTwo(n) {\n    // 1. Debe ser positivo\n    // 2. n & (n - 1) debe ser cero para números con un solo bit establecido\n    return n > 0 && (n & (n - 1)) === 0;\n}",
                "complexity": "Time: O(1), Space: O(1)",
                "example": {
                    "input": "16",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "16"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "16",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "16",
                                "result": "true (10000 & 01111 = 0)"
                            },
                            "code_line": "return resultado",
                            "output": "true (10000 & 01111 = 0)"
                        }
                    ],
                    "final_output": "true (10000 & 01111 = 0)"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function isPowerOfTwo(n) {\n    // 1. Debe ser positivo\n    // 2. n & (n - 1) debe ser cero para números con un solo bit establecido\n    return n > 0 && (n & (n - 1)) === 0;\n} // Variación alternativa",
                "complexity": "Time: O(1), Space: O(1)",
                "example": {
                    "input": "16",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "16"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "16",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "16",
                                "result": "true (10000 & 01111 = 0)"
                            },
                            "code_line": "return resultado",
                            "output": "true (10000 & 01111 = 0)"
                        }
                    ],
                    "final_output": "true (10000 & 01111 = 0)"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function isPowerOfTwo(n) {\n    // 1. Debe ser positivo\n    // 2. n & (n - 1) debe ser cero para números con un solo bit establecido\n    return n > 0 && (n & (n - 1)) === 0;\n} // Variación alternativa",
                "complexity": "Time: O(1), Space: O(1)",
                "example": {
                    "input": "16",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "16"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "16",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "16",
                                "result": "true (10000 & 01111 = 0)"
                            },
                            "code_line": "return resultado",
                            "output": "true (10000 & 01111 = 0)"
                        }
                    ],
                    "final_output": "true (10000 & 01111 = 0)"
                }
            }
        ]
    },
    {
        "id": "happy-number",
        "title": "202. Happy Number",
        "difficulty": "Easy",
        "description": "Un 'número feliz' es un número definido por el siguiente proceso: reemplaza el número por la suma de los cuadrados de sus dígitos. Repite el proceso hasta que el número sea 1 (donde permanecerá) o entre en un ciclo infinito que no incluye 1. Devuelve `true` si `n` es un número feliz, y `false` en caso contrario.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Detección de Ciclos (Floyd's Cycle-Finding Algorithm)",
                "explanation": "El proceso de 'felicidad' genera una secuencia. Si la secuencia no llega a 1, debe entrar en un ciclo. Para detectar ciclos sin usar un Set para almacenar todos los números visitados, usamos el algoritmo de la tortuga y la liebre (slow and fast pointers), comúnmente usado en listas enlazadas. Si `slow` (avanza 1 paso) y `fast` (avanza 2 pasos) se encuentran en un valor que no es 1, hemos detectado un ciclo y el número no es feliz.",
                "code_snippet": "function getNext(n) {\n    let sum = 0;\n    while (n > 0) {\n        const digit = n % 10;\n        sum += digit * digit;\n        n = Math.floor(n / 10);\n    }\n    return sum;\n}\n\nfunction isHappy(n) {\n    let slow = n;\n    let fast = getNext(n);\n    \n    while (fast !== 1 && slow !== fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    \n    // Si fast llegó a 1, es feliz. Si slow === fast (pero no 1), es un ciclo infeliz.\n    return fast === 1;\n}",
                "complexity": "Time: O(log N). El número de pasos necesarios es limitado por el hecho de que la secuencia eventualmente cae por debajo de 243, y el ciclo se detecta rápidamente. Space: O(1)",
                "example": {
                    "input": "19",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "19"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "19",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "19",
                                "result": "true"
                            },
                            "code_line": "return resultado",
                            "output": "true"
                        }
                    ],
                    "final_output": "true"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function getNext(n) {\n    let sum = 0;\n    while (n > 0) {\n        const digit = n % 10;\n        sum += digit * digit;\n        n = Math.floor(n / 10);\n    }\n    return sum;\n}\n\nfunction isHappy(n) {\n    let slow = n;\n    let fast = getNext(n);\n    \n    while (fast !== 1 && slow !== fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    \n    // Si fast llegó a 1, es feliz. Si slow === fast (pero no 1), es un ciclo infeliz.\n    return fast === 1;\n} // Variación alternativa",
                "complexity": "Time: O(log N). El número de pasos necesarios es limitado por el hecho de que la secuencia eventualmente cae por debajo de 243, y el ciclo se detecta rápidamente. Space: O(1)",
                "example": {
                    "input": "19",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "19"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "19",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "19",
                                "result": "true"
                            },
                            "code_line": "return resultado",
                            "output": "true"
                        }
                    ],
                    "final_output": "true"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function getNext(n) {\n    let sum = 0;\n    while (n > 0) {\n        const digit = n % 10;\n        sum += digit * digit;\n        n = Math.floor(n / 10);\n    }\n    return sum;\n}\n\nfunction isHappy(n) {\n    let slow = n;\n    let fast = getNext(n);\n    \n    while (fast !== 1 && slow !== fast) {\n        slow = getNext(slow);\n        fast = getNext(getNext(fast));\n    }\n    \n    // Si fast llegó a 1, es feliz. Si slow === fast (pero no 1), es un ciclo infeliz.\n    return fast === 1;\n} // Variación alternativa",
                "complexity": "Time: O(log N). El número de pasos necesarios es limitado por el hecho de que la secuencia eventualmente cae por debajo de 243, y el ciclo se detecta rápidamente. Space: O(1)",
                "example": {
                    "input": "19",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "19"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "19",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "19",
                                "result": "true"
                            },
                            "code_line": "return resultado",
                            "output": "true"
                        }
                    ],
                    "final_output": "true"
                }
            }
        ]
    },
    {
        "id": "valid-anagram",
        "title": "242. Valid Anagram",
        "difficulty": "Easy",
        "description": "Dadas dos cadenas `s` y `t`, devuelve `true` si `t` es un anagrama de `s`, y `false` en caso contrario. Un anagrama es una palabra o frase formada al reordenar las letras de otra.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Contadores de Frecuencia (Array de 26)",
                "explanation": "Dos cadenas son anagramas si, y solo si, tienen exactamente el mismo número de cada carácter. Primero verificamos si las longitudes son iguales. Luego, usamos un array de tamaño 26 para rastrear la frecuencia de cada letra. Incrementamos el contador para los caracteres en `s` y decrementamos para los caracteres en `t`. Si al final todos los conteos son cero, son anagramas.",
                "code_snippet": "function isAnagram(s, t) {\n    if (s.length !== t.length) return false;\n    \n    const counts = new Array(26).fill(0);\n    const base = 'a'.charCodeAt(0);\n    \n    // 1. Contar s e 'descontar' t\n    for (let i = 0; i < s.length; i++) {\n        counts[s.charCodeAt(i) - base]++;\n        counts[t.charCodeAt(i) - base]--;\n    }\n    \n    // 2. Verificar que todos los conteos sean cero\n    for (const count of counts) {\n        if (count !== 0) return false;\n    }\n    \n    return true;\n}",
                "complexity": "Time: O(N), Space: O(1) (por el array de 26)",
                "example": {
                    "input": "s = \"anagram\", t = \"nagaram\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "s = \"anagram\", t = \"nagaram\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "s = \"anagram\", t = \"nagaram\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "s = \"anagram\", t = \"nagaram\"",
                                "result": "true"
                            },
                            "code_line": "return resultado",
                            "output": "true"
                        }
                    ],
                    "final_output": "true"
                }
            },
            {
                "id": 2,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function isAnagram(s, t) {\n    if (s.length !== t.length) return false;\n    \n    const counts = new Array(26).fill(0);\n    const base = 'a'.charCodeAt(0);\n    \n    // 1. Contar s e 'descontar' t\n    for (let i = 0; i < s.length; i++) {\n        counts[s.charCodeAt(i) - base]++;\n        counts[t.charCodeAt(i) - base]--;\n    }\n    \n    // 2. Verificar que todos los conteos sean cero\n    for (const count of counts) {\n        if (count !== 0) return false;\n    }\n    \n    return true;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1) (por el array de 26)",
                "example": {
                    "input": "s = \"anagram\", t = \"nagaram\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "s = \"anagram\", t = \"nagaram\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "s = \"anagram\", t = \"nagaram\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "s = \"anagram\", t = \"nagaram\"",
                                "result": "true"
                            },
                            "code_line": "return resultado",
                            "output": "true"
                        }
                    ],
                    "final_output": "true"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Optimizada con Estructura de Datos Alternativa",
                "explanation": "Una variación optimizada que utiliza una estructura de datos diferente o una técnica alternativa para lograr la misma complejidad o mejorar ciertos aspectos del algoritmo original.",
                "code_snippet": "function isAnagram(s, t) {\n    if (s.length !== t.length) return false;\n    \n    const counts = new Array(26).fill(0);\n    const base = 'a'.charCodeAt(0);\n    \n    // 1. Contar s e 'descontar' t\n    for (let i = 0; i < s.length; i++) {\n        counts[s.charCodeAt(i) - base]++;\n        counts[t.charCodeAt(i) - base]--;\n    }\n    \n    // 2. Verificar que todos los conteos sean cero\n    for (const count of counts) {\n        if (count !== 0) return false;\n    }\n    \n    return true;\n} // Variación alternativa",
                "complexity": "Time: O(N), Space: O(1) (por el array de 26)",
                "example": {
                    "input": "s = \"anagram\", t = \"nagaram\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "s = \"anagram\", t = \"nagaram\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "s = \"anagram\", t = \"nagaram\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "s = \"anagram\", t = \"nagaram\"",
                                "result": "true"
                            },
                            "code_line": "return resultado",
                            "output": "true"
                        }
                    ],
                    "final_output": "true"
                }
            }
        ]
    },
    {
        "id": "climbing-stairs",
        "title": "070. Climbing Stairs",
        "difficulty": "Easy",
        "description": "Estás subiendo una escalera. Se necesitan `n` escalones para llegar a la cima. Cada vez puedes subir 1 o 2 escalones. ¿De cuántas maneras distintas puedes subir hasta la cima?",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Programación Dinámica (Bottom-Up)",
                "explanation": "Este es un problema clásico de programación dinámica que sigue la secuencia de Fibonacci. El número de formas de llegar al escalón `i` es la suma de las formas de llegar al escalón `i-1` (dando un paso) y las formas de llegar al escalón `i-2` (dando dos pasos). Construimos una tabla `dp` desde la base (0 y 1 escalones) hasta `n`.",
                "code_snippet": "function climbStairs(n) {\n    if (n <= 2) return n;\n    \n    let dp = new Array(n + 1);\n    dp[1] = 1;\n    dp[2] = 2;\n    \n    for (let i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    \n    return dp[n];\n}",
                "complexity": "Time: O(N), Space: O(N)",
                "example": {
                    "input": "4",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "4"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "4",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "4",
                                "result": "5 (1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2)"
                            },
                            "code_line": "return resultado",
                            "output": "5 (1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2)"
                        }
                    ],
                    "final_output": "5 (1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2)"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Programación Dinámica Optimizada (Fibonacci)",
                "explanation": "Notamos que para calcular `dp[i]`, solo necesitamos los dos valores anteriores (`dp[i-1]` y `dp[i-2]`). Por lo tanto, no necesitamos un array completo, solo dos variables para almacenar los dos números de Fibonacci anteriores. Esto reduce el espacio a O(1).",
                "code_snippet": "function climbStairs(n) {\n    if (n <= 2) return n;\n    \n    let one_step_before = 2;\n    let two_steps_before = 1;\n    let all_ways = 0;\n    \n    for (let i = 3; i <= n; i++) {\n        all_ways = one_step_before + two_steps_before;\n        two_steps_before = one_step_before;\n        one_step_before = all_ways;\n    }\n    \n    return all_ways;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "4",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "4"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "4",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "4",
                                "result": "5"
                            },
                            "code_line": "return resultado",
                            "output": "5"
                        }
                    ],
                    "final_output": "5"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Recursión con Memoización (Top-Down)",
                "explanation": "La solución recursiva directa (`climb(n) = climb(n-1) + climb(n-2)`) es ineficiente debido a cálculos repetidos (O(2^n)). Podemos optimizarla drásticamente utilizando memoización: almacenamos el resultado de cada subproblema (escalón `i`) en un mapa o array la primera vez que se calcula. Las llamadas posteriores para el mismo escalón devuelven el resultado almacenado en tiempo O(1).",
                "code_snippet": "function climbStairs(n) {\n    const memo = new Map();\n\n    function climb(k) {\n        if (k <= 2) return k;\n        if (memo.has(k)) return memo.get(k);\n\n        const result = climb(k - 1) + climb(k - 2);\n        memo.set(k, result);\n        return result;\n    }\n\n    return climb(n);\n}",
                "complexity": "Time: O(N), Space: O(N) [por la pila de recursión y el mapa]",
                "example": {
                    "input": "4",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "4"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "4",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "4",
                                "result": "5"
                            },
                            "code_line": "return resultado",
                            "output": "5"
                        }
                    ],
                    "final_output": "5"
                }
            }
        ]
    },
    {
        "id": "reverse-linked-list",
        "title": "206. Reverse Linked List",
        "difficulty": "Easy",
        "description": "Dada la cabeza de una lista enlazada simple, invierte la lista y devuelve la nueva cabeza.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Iterativa con Tres Punteros",
                "explanation": "Esta es la solución más común y eficiente en espacio. Utilizamos tres punteros: `prev` (inicialmente `null`), `current` (inicialmente `head`) y `nextTemp`. En cada paso, guardamos el siguiente nodo (`nextTemp`), revertimos el puntero del nodo actual para que apunte a `prev`, y luego movemos `prev` y `current` un paso hacia adelante.",
                "code_snippet": "function reverseList(head) {\n    let prev = null;\n    let current = head;\n    \n    while (current !== null) {\n        const nextTemp = current.next; // Guardar el siguiente nodo\n        current.next = prev;         // Revertir el puntero\n        prev = current;              // Mover prev hacia adelante\n        current = nextTemp;          // Mover current hacia adelante\n    }\n    \n    // Al final, prev es la nueva cabeza\n    return prev;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "1 -> 2 -> 3 -> NULL",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "1 -> 2 -> 3 -> NULL"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "1 -> 2 -> 3 -> NULL",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "1 -> 2 -> 3 -> NULL",
                                "result": "3 -> 2 -> 1 -> NULL"
                            },
                            "code_line": "return resultado",
                            "output": "3 -> 2 -> 1 -> NULL"
                        }
                    ],
                    "final_output": "3 -> 2 -> 1 -> NULL"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Recursiva",
                "explanation": "La recursión divide el problema: asume que el resto de la lista (`head.next`) ya ha sido invertido. La tarea es entonces hacer que el siguiente nodo (`head.next`) apunte de vuelta a la cabeza actual (`head`), y que la cabeza actual apunte a `null`. El caso base es cuando la cabeza es nula o es el último nodo.",
                "code_snippet": "function reverseList(head) {\n    // Caso base: lista vacía o de un solo nodo\n    if (head === null || head.next === null) {\n        return head;\n    }\n    \n    // Invertir el resto de la lista\n    const newHead = reverseList(head.next);\n    \n    // Re-enlazar\n    head.next.next = head; // El nodo que era el siguiente ahora apunta hacia atrás, a mí\n    head.next = null;      // Mi puntero 'next' ahora es null, convirtiéndome en la nueva cola\n    \n    return newHead;\n}",
                "complexity": "Time: O(N), Space: O(N) [por la pila de recursión]",
                "example": {
                    "input": "1 -> 2 -> 3 -> NULL",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "1 -> 2 -> 3 -> NULL"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "1 -> 2 -> 3 -> NULL",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "1 -> 2 -> 3 -> NULL",
                                "result": "3 -> 2 -> 1 -> NULL"
                            },
                            "code_line": "return resultado",
                            "output": "3 -> 2 -> 1 -> NULL"
                        }
                    ],
                    "final_output": "3 -> 2 -> 1 -> NULL"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Usando una Pila (Stack)",
                "explanation": "Este enfoque es más intuitivo pero menos eficiente en espacio. Primero, recorremos la lista enlazada y empujamos cada nodo a una pila. Debido a la naturaleza LIFO (Last-In, First-Out) de la pila, los nodos se almacenan en orden inverso. Luego, creamos una nueva lista extrayendo los nodos de la pila y enlazándolos.",
                "code_snippet": "function reverseList(head) {\n    if (!head) return null;\n    \n    const stack = [];\n    let current = head;\n    while (current) {\n        stack.push(current);\n        current = current.next;\n    }\n    \n    const newHead = stack.pop();\n    current = newHead;\n    \n    while (stack.length > 0) {\n        current.next = stack.pop();\n        current = current.next;\n    }\n    \n    current.next = null; // Asegurar que el último nodo apunte a null\n    return newHead;\n}",
                "complexity": "Time: O(N), Space: O(N)",
                "example": {
                    "input": "1 -> 2 -> 3 -> NULL",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "1 -> 2 -> 3 -> NULL"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "1 -> 2 -> 3 -> NULL",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "1 -> 2 -> 3 -> NULL",
                                "result": "3 -> 2 -> 1 -> NULL"
                            },
                            "code_line": "return resultado",
                            "output": "3 -> 2 -> 1 -> NULL"
                        }
                    ],
                    "final_output": "3 -> 2 -> 1 -> NULL"
                }
            }
        ]
    },
    {
        "id": "validate-binary-search-tree",
        "title": "098. Validate Binary Search Tree",
        "difficulty": "Medium",
        "description": "Dado el `root` de un árbol binario, determina si es un Árbol de Búsqueda Binario (BST) válido. Un BST válido se define como: el subárbol izquierdo de un nodo contiene solo nodos con claves menores que la clave del nodo; el subárbol derecho contiene solo nodos con claves mayores; y ambos subárboles (izquierdo y derecho) también deben ser árboles de búsqueda binarios.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Recursión con Rango Válido (min, max)",
                "explanation": "Un error común es solo verificar `node.left.val < node.val` y `node.right.val > node.val`. La solución correcta es asegurar que todos los nodos en el subárbol izquierdo sean menores que el nodo actual y que todos los del subárbol derecho sean mayores. Esto se logra pasando un rango de valores permitidos (`min`, `max`) en cada llamada recursiva. Para un nodo, todos sus descendientes izquierdos deben ser mayores que `min` y menores que `node.val`.",
                "code_snippet": "function isValidBST(root) {\n    function validate(node, min, max) {\n        if (!node) return true;\n        \n        if ((min !== null && node.val <= min) || (max !== null && node.val >= max)) {\n            return false;\n        }\n        \n        // El subárbol izquierdo debe estar entre min y node.val\n        // El subárbol derecho debe estar entre node.val y max\n        return validate(node.left, min, node.val) && validate(node.right, node.val, max);\n    }\n    \n    return validate(root, null, null);\n}",
                "complexity": "Time: O(N), Space: O(H) [Altura del árbol]",
                "example": {
                    "input": "[5, 1, 7, null, null, 6, 8]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[5, 1, 7, null, null, 6, 8]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[5, 1, 7, null, null, 6, 8]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[5, 1, 7, null, null, 6, 8]",
                                "result": "false (6 es menor que 7 pero está en su subárbol izquierdo)"
                            },
                            "code_line": "return resultado",
                            "output": "false (6 es menor que 7 pero está en su subárbol izquierdo)"
                        }
                    ],
                    "final_output": "false (6 es menor que 7 pero está en su subárbol izquierdo)"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Recorrido In-Order (DFS)",
                "explanation": "Una propiedad clave de un BST es que un recorrido in-order (izquierda, raíz, derecha) visita los nodos en orden ascendente estricto. Podemos realizar un recorrido in-order y mantener un registro del valor del nodo visitado previamente. Si en algún momento el valor del nodo actual es menor o igual que el valor del nodo previo, el árbol no es un BST.",
                "code_snippet": "function isValidBST(root) {\n    let prev = -Infinity;\n\n    function inOrder(node) {\n        if (!node) return true;\n\n        // 1. Recorrer subárbol izquierdo\n        if (!inOrder(node.left)) return false;\n\n        // 2. Procesar nodo actual (verificar orden)\n        if (node.val <= prev) return false;\n        prev = node.val;\n\n        // 3. Recorrer subárbol derecho\n        return inOrder(node.right);\n    }\n\n    return inOrder(root);\n}",
                "complexity": "Time: O(N), Space: O(H) [Altura del árbol]",
                "example": {
                    "input": "[2, 1, 3]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[2, 1, 3]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[2, 1, 3]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[2, 1, 3]",
                                "result": "true"
                            },
                            "code_line": "return resultado",
                            "output": "true"
                        }
                    ],
                    "final_output": "true"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Recorrido In-Order Iterativo con Pila",
                "explanation": "Esta solución evita la recursión profunda para árboles desbalanceados, utilizando una pila explícita para simular el recorrido in-order. Empujamos los nodos izquierdos a la pila hasta llegar al más izquierdo. Luego, extraemos un nodo, verificamos su valor contra el `previo` (como en la solución 2), y luego procesamos su subárbol derecho.",
                "code_snippet": "function isValidBST(root) {\n    const stack = [];\n    let prev = -Infinity;\n    let current = root;\n\n    while (current !== null || stack.length > 0) {\n        // Ir al hijo más a la izquierda\n        while (current !== null) {\n            stack.push(current);\n            current = current.left;\n        }\n\n        current = stack.pop();\n\n        // Procesar nodo (verificar orden)\n        if (current.val <= prev) return false;\n        prev = current.val;\n\n        // Mover al subárbol derecho\n        current = current.right;\n    }\n\n    return true;\n}",
                "complexity": "Time: O(N), Space: O(H) [Altura del árbol]",
                "example": {
                    "input": "[5, 4, 6, null, null, 3, 7]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[5, 4, 6, null, null, 3, 7]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[5, 4, 6, null, null, 3, 7]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[5, 4, 6, null, null, 3, 7]",
                                "result": "false"
                            },
                            "code_line": "return resultado",
                            "output": "false"
                        }
                    ],
                    "final_output": "false"
                }
            }
        ]
    },
    {
        "id": "product-of-array-except-self",
        "title": "238. Product of Array Except Self",
        "difficulty": "Medium",
        "description": "Dado un array de enteros `nums`, devuelve un array `answer` tal que `answer[i]` es igual al producto de todos los elementos de `nums` excepto `nums[i]`. Debes resolverlo sin usar el operador de división y en tiempo O(N).",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Usando Arrays de Prefijos y Sufijos",
                "explanation": "La clave es darse cuenta de que el producto deseado en el índice `i` es (`producto de todos los elementos a la izquierda de i`) * (`producto de todos los elementos a la derecha de i`). Podemos precalcular estos productos en dos arrays separados: uno para los prefijos y otro para los sufijos. Luego, multiplicamos los valores correspondientes para obtener el resultado final.",
                "code_snippet": "function productExceptSelf(nums) {\n    const n = nums.length;\n    const leftProducts = new Array(n).fill(1);\n    const rightProducts = new Array(n).fill(1);\n    const answer = new Array(n);\n\n    // Calcular productos de prefijos\n    for (let i = 1; i < n; i++) {\n        leftProducts[i] = leftProducts[i - 1] * nums[i - 1];\n    }\n\n    // Calcular productos de sufijos\n    for (let i = n - 2; i >= 0; i--) {\n        rightProducts[i] = rightProducts[i + 1] * nums[i + 1];\n    }\n\n    // Calcular la respuesta final\n    for (let i = 0; i < n; i++) {\n        answer[i] = leftProducts[i] * rightProducts[i];\n    }\n\n    return answer;\n}",
                "complexity": "Time: O(N), Space: O(N)",
                "example": {
                    "input": "[1, 2, 3, 4]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[1, 2, 3, 4]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[1, 2, 3, 4]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[1, 2, 3, 4]",
                                "result": "[24, 12, 8, 6]"
                            },
                            "code_line": "return resultado",
                            "output": "[24, 12, 8, 6]"
                        }
                    ],
                    "final_output": "[24, 12, 8, 6]"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Óptima con Espacio O(1)",
                "explanation": "Podemos optimizar la solución anterior para usar espacio constante (sin contar el array de salida). Primero, llenamos el array de respuesta con los productos de prefijos en una pasada. Luego, en una segunda pasada de derecha a izquierda, calculamos los productos de sufijos sobre la marcha con una variable y los multiplicamos por los prefijos ya almacenados en el array de respuesta.",
                "code_snippet": "function productExceptSelf(nums) {\n    const n = nums.length;\n    const answer = new Array(n).fill(1);\n\n    // 1. Llenar con productos de prefijos\n    for (let i = 1; i < n; i++) {\n        answer[i] = answer[i - 1] * nums[i - 1];\n    }\n\n    // 2. Multiplicar por productos de sufijos sobre la marcha\n    let rightProduct = 1;\n    for (let i = n - 1; i >= 0; i--) {\n        answer[i] *= rightProduct;\n        rightProduct *= nums[i];\n    }\n\n    return answer;\n}",
                "complexity": "Time: O(N), Space: O(1) [sin contar el array de salida]",
                "example": {
                    "input": "[1, 2, 3, 4]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[1, 2, 3, 4]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[1, 2, 3, 4]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[1, 2, 3, 4]",
                                "result": "[24, 12, 8, 6]"
                            },
                            "code_line": "return resultado",
                            "output": "[24, 12, 8, 6]"
                        }
                    ],
                    "final_output": "[24, 12, 8, 6]"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Fuerza Bruta (Ineficiente)",
                "explanation": "La forma más directa pero ineficiente es usar dos bucles anidados. Para cada elemento en el índice `i`, iteramos a través de todo el array nuevamente, multiplicando todos los elementos excepto el que se encuentra en `i`. Aunque es fácil de entender, su complejidad cuadrática lo hace inadecuado para arrays grandes.",
                "code_snippet": "function productExceptSelf(nums) {\n    const n = nums.length;\n    const answer = [];\n    \n    for (let i = 0; i < n; i++) {\n        let product = 1;\n        for (let j = 0; j < n; j++) {\n            if (i !== j) {\n                product *= nums[j];\n            }\n        }\n        answer.push(product);\n    }\n    \n    return answer;\n}",
                "complexity": "Time: O(N^2), Space: O(1) [sin contar el array de salida]",
                "example": {
                    "input": "[1, 2, 3, 4]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[1, 2, 3, 4]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[1, 2, 3, 4]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[1, 2, 3, 4]",
                                "result": "[24, 12, 8, 6]"
                            },
                            "code_line": "return resultado",
                            "output": "[24, 12, 8, 6]"
                        }
                    ],
                    "final_output": "[24, 12, 8, 6]"
                }
            }
        ]
    },
    {
        "id": "binary-tree-level-order-traversal",
        "title": "102. Binary Tree Level Order Traversal",
        "difficulty": "Medium",
        "description": "Dado el `root` de un árbol binario, devuelve el recorrido por niveles de los valores de sus nodos (es decir, de izquierda a derecha, nivel por nivel).",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Iterativa con Cola (BFS)",
                "explanation": "Este es el enfoque estándar para el recorrido por niveles, utilizando Búsqueda en Anchura (BFS). Usamos una cola para mantener los nodos de cada nivel. En cada iteración del bucle principal, procesamos todos los nodos del nivel actual (determinando el tamaño de la cola al inicio del bucle). Para cada nodo extraído, agregamos su valor al resultado del nivel y encolamos a sus hijos.",
                "code_snippet": "function levelOrder(root) {\n    if (!root) return [];\n\n    const queue = [root];\n    const result = [];\n\n    while (queue.length > 0) {\n        const levelSize = queue.length;\n        const currentLevel = [];\n\n        for (let i = 0; i < levelSize; i++) {\n            const node = queue.shift();\n            currentLevel.push(node.val);\n\n            if (node.left) queue.push(node.left);\n            if (node.right) queue.push(node.right);\n        }\n        result.push(currentLevel);\n    }\n\n    return result;\n}",
                "complexity": "Time: O(N), Space: O(W) [Ancho máximo del árbol]",
                "example": {
                    "input": "[3, 9, 20, null, null, 15, 7]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[3, 9, 20, null, null, 15, 7]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[3, 9, 20, null, null, 15, 7]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[3, 9, 20, null, null, 15, 7]",
                                "result": "[[3],[9,20],[15,7]]"
                            },
                            "code_line": "return resultado",
                            "output": "[[3],[9,20],[15,7]]"
                        }
                    ],
                    "final_output": "[[3],[9,20],[15,7]]"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Recursiva con Profundidad (DFS)",
                "explanation": "Aunque BFS es más natural, también podemos usar Búsqueda en Profundidad (DFS). Creamos una función auxiliar que toma el nodo y su nivel actual. Mantenemos un array de resultados donde el índice corresponde al nivel. Cuando visitamos un nodo en un nivel `d`, si `result[d]` no existe, lo creamos. Luego, agregamos el valor del nodo a `result[d]` y llamamos recursivamente para los hijos en el nivel `d+1`.",
                "code_snippet": "function levelOrder(root) {\n    const result = [];\n\n    function dfs(node, level) {\n        if (!node) return;\n\n        // Si el nivel no existe en el resultado, créalo\n        if (level === result.length) {\n            result.push([]);\n        }\n\n        // Agrega el valor del nodo al nivel correspondiente\n        result[level].push(node.val);\n\n        // Llama recursivamente para los hijos\n        dfs(node.left, level + 1);\n        dfs(node.right, level + 1);\n    }\n\n    dfs(root, 0);\n    return result;\n}",
                "complexity": "Time: O(N), Space: O(H) [Altura del árbol para la pila de recursión]",
                "example": {
                    "input": "[3, 9, 20, null, null, 15, 7]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[3, 9, 20, null, null, 15, 7]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[3, 9, 20, null, null, 15, 7]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[3, 9, 20, null, null, 15, 7]",
                                "result": "[[3],[9,20],[15,7]]"
                            },
                            "code_line": "return resultado",
                            "output": "[[3],[9,20],[15,7]]"
                        }
                    ],
                    "final_output": "[[3],[9,20],[15,7]]"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: BFS con Dos Colas",
                "explanation": "Una variación del BFS que evita la necesidad de obtener el tamaño de la cola en cada nivel. Se utilizan dos colas: `currentLevelQueue` y `nextLevelQueue`. Mientras la cola del nivel actual no esté vacía, extraemos nodos, procesamos sus valores y agregamos sus hijos a la cola del siguiente nivel. Una vez que la cola actual está vacía, el nivel se ha procesado, y cambiamos las colas para la siguiente iteración.",
                "code_snippet": "function levelOrder(root) {\n    if (!root) return [];\n    \n    let currentLevelQueue = [root];\n    let result = [];\n\n    while (currentLevelQueue.length > 0) {\n        let nextLevelQueue = [];\n        let currentLevelValues = [];\n\n        for (const node of currentLevelQueue) {\n            currentLevelValues.push(node.val);\n            if (node.left) nextLevelQueue.push(node.left);\n            if (node.right) nextLevelQueue.push(node.right);\n        }\n        \n        result.push(currentLevelValues);\n        currentLevelQueue = nextLevelQueue;\n    }\n\n    return result;\n}",
                "complexity": "Time: O(N), Space: O(W) [Ancho máximo del árbol]",
                "example": {
                    "input": "[3, 9, 20, null, null, 15, 7]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[3, 9, 20, null, null, 15, 7]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[3, 9, 20, null, null, 15, 7]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[3, 9, 20, null, null, 15, 7]",
                                "result": "[[3],[9,20],[15,7]]"
                            },
                            "code_line": "return resultado",
                            "output": "[[3],[9,20],[15,7]]"
                        }
                    ],
                    "final_output": "[[3],[9,20],[15,7]]"
                }
            }
        ]
    },
    {
        "id": "3sum",
        "title": "015. 3Sum",
        "difficulty": "Medium",
        "description": "Dado un array de enteros `nums`, encuentra todos los tripletes únicos `[nums[i], nums[j], nums[k]]` tales que `i != j`, `i != k`, `j != k`, y `nums[i] + nums[j] + nums[k] == 0`.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Fuerza Bruta",
                "explanation": "La solución más directa es usar tres bucles anidados para iterar sobre todas las combinaciones posibles de tres números. Para evitar duplicados en el resultado, se ordena cada triplete encontrado y se almacena en un Set para garantizar la unicidad.",
                "code_snippet": "function threeSum(nums) {\n    const result = [];\n    nums.sort((a, b) => a - b);\n    for (let i = 0; i < nums.length - 2; i++) {\n        // Evitar duplicados para el primer número\n        if (i > 0 && nums[i] === nums[i - 1]) continue;\n        for (let j = i + 1; j < nums.length - 1; j++) {\n            // Evitar duplicados para el segundo número\n            if (j > i + 1 && nums[j] === nums[j - 1]) continue;\n            for (let k = j + 1; k < nums.length; k++) {\n                // Evitar duplicados para el tercer número\n                if (k > j + 1 && nums[k] === nums[k - 1]) continue;\n                if (nums[i] + nums[j] + nums[k] === 0) {\n                    result.push([nums[i], nums[j], nums[k]]);\n                }\n            }\n        }\n    }\n    return result;\n}",
                "complexity": "Time: O(N^3), Space: O(1) [sin contar la salida]",
                "example": {
                    "input": "[-1, 0, 1, 2, -1, -4]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[-1, 0, 1, 2, -1, -4]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[-1, 0, 1, 2, -1, -4]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[-1, 0, 1, 2, -1, -4]",
                                "result": "[[-1, -1, 2], [-1, 0, 1]]"
                            },
                            "code_line": "return resultado",
                            "output": "[[-1, -1, 2], [-1, 0, 1]]"
                        }
                    ],
                    "final_output": "[[-1, -1, 2], [-1, 0, 1]]"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Hash Set (Variación de Two Sum)",
                "explanation": "Iteramos a través del array con un puntero `i`. Para cada `nums[i]`, el problema se reduce a encontrar dos números en el resto del array que sumen `-nums[i]` (un problema de Two Sum). Podemos resolver este subproblema en tiempo O(N) usando un Hash Set, lo que da una complejidad total de O(N^2). La gestión de duplicados es crucial.",
                "code_snippet": "function threeSum(nums) {\n    const result = [];\n    nums.sort((a, b) => a - b);\n\n    for (let i = 0; i < nums.length; i++) {\n        if (i > 0 && nums[i] === nums[i - 1]) continue; // Evitar duplicados\n        \n        const seen = new Set();\n        for (let j = i + 1; j < nums.length; j++) {\n            const complement = -nums[i] - nums[j];\n            if (seen.has(complement)) {\n                result.push([nums[i], complement, nums[j]]);\n                // Saltar duplicados para el tercer número\n                while (j + 1 < nums.length && nums[j] === nums[j + 1]) j++;\n            }\n            seen.add(nums[j]);\n        }\n    }\n    return result;\n}",
                "complexity": "Time: O(N^2), Space: O(N)",
                "example": {
                    "input": "[-1, 0, 1, 2, -1, -4]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[-1, 0, 1, 2, -1, -4]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[-1, 0, 1, 2, -1, -4]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[-1, 0, 1, 2, -1, -4]",
                                "result": "[[-1, -1, 2], [-1, 0, 1]]"
                            },
                            "code_line": "return resultado",
                            "output": "[[-1, -1, 2], [-1, 0, 1]]"
                        }
                    ],
                    "final_output": "[[-1, -1, 2], [-1, 0, 1]]"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Two Pointers (Óptima)",
                "explanation": "La solución más eficiente. Primero, ordenamos el array. Luego, iteramos con un puntero `i`. Para cada `nums[i]`, usamos dos punteros, `left` (en `i+1`) y `right` (al final del array), que se mueven hacia el centro. Si la suma es menor que 0, movemos `left` a la derecha. Si es mayor, movemos `right` a la izquierda. Si es 0, hemos encontrado un triplete, lo guardamos y movemos ambos punteros, saltando duplicados.",
                "code_snippet": "function threeSum(nums) {\n    nums.sort((a, b) => a - b);\n    const result = [];\n\n    for (let i = 0; i < nums.length - 2; i++) {\n        if (i > 0 && nums[i] === nums[i - 1]) continue; // Evitar duplicados del primer número\n\n        let left = i + 1;\n        let right = nums.length - 1;\n\n        while (left < right) {\n            const sum = nums[i] + nums[left] + nums[right];\n            if (sum === 0) {\n                result.push([nums[i], nums[left], nums[right]]);\n                // Saltar duplicados\n                while (left < right && nums[left] === nums[left + 1]) left++;\n                while (left < right && nums[right] === nums[right - 1]) right--;\n                left++;\n                right--;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return result;\n}",
                "complexity": "Time: O(N^2), Space: O(1) o O(log N) [por la ordenación]",
                "example": {
                    "input": "[-1, 0, 1, 2, -1, -4]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[-1, 0, 1, 2, -1, -4]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[-1, 0, 1, 2, -1, -4]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[-1, 0, 1, 2, -1, -4]",
                                "result": "[[-1, -1, 2], [-1, 0, 1]]"
                            },
                            "code_line": "return resultado",
                            "output": "[[-1, -1, 2], [-1, 0, 1]]"
                        }
                    ],
                    "final_output": "[[-1, -1, 2], [-1, 0, 1]]"
                }
            }
        ]
    },
    {
        "id": "merge-intervals",
        "title": "056. Merge Intervals",
        "difficulty": "Medium",
        "description": "Dado un array de `intervals` donde `intervals[i] = [starti, endi]`, fusiona todos los intervalos superpuestos y devuelve un array de los intervalos no superpuestos que cubren todos los intervalos de la entrada.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Ordenar y Fusionar (Óptima)",
                "explanation": "El enfoque más eficiente. Primero, ordenamos los intervalos basándonos en su valor de inicio. Luego, iteramos a través de los intervalos ordenados. Mantenemos una lista de resultados. Si el intervalo actual se superpone con el último intervalo en nuestra lista de resultados, fusionamos ambos actualizando el final del último intervalo. Si no se superpone, simplemente lo añadimos a la lista de resultados.",
                "code_snippet": "function merge(intervals) {\n    if (intervals.length === 0) return [];\n\n    // 1. Ordenar por el inicio del intervalo\n    intervals.sort((a, b) => a[0] - b[0]);\n\n    const merged = [intervals[0]];\n\n    for (let i = 1; i < intervals.length; i++) {\n        const lastMerged = merged[merged.length - 1];\n        const current = intervals[i];\n\n        // Comprobar superposición\n        if (current[0] <= lastMerged[1]) {\n            // Fusionar actualizando el final\n            lastMerged[1] = Math.max(lastMerged[1], current[1]);\n        } else {\n            // No hay superposición, añadir el intervalo\n            merged.push(current);\n        }\n    }\n    return merged;\n}",
                "complexity": "Time: O(N log N) [dominado por la ordenación], Space: O(N) [en el peor caso]",
                "example": {
                    "input": "[[1,3],[2,6],[8,10],[15,18]]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[[1,3],[2,6],[8,10],[15,18]]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[[1,3],[2,6],[8,10],[15,18]]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[[1,3],[2,6],[8,10],[15,18]]",
                                "result": "[[1,6],[8,10],[15,18]]"
                            },
                            "code_line": "return resultado",
                            "output": "[[1,6],[8,10],[15,18]]"
                        }
                    ],
                    "final_output": "[[1,6],[8,10],[15,18]]"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Fuerza Bruta con Búsqueda Repetida",
                "explanation": "Un enfoque menos eficiente. Usamos un bucle que se repite hasta que no se puedan realizar más fusiones. Dentro del bucle, iteramos sobre todos los pares de intervalos. Si encontramos un par que se superpone, los fusionamos en un nuevo intervalo, eliminamos los dos originales y añadimos el nuevo. Este proceso es ineficiente debido a las repetidas búsquedas y modificaciones de la lista.",
                "code_snippet": "// Esta implementación es compleja y propensa a errores, se muestra conceptualmente.\nfunction merge(intervals) {\n    let merged = true;\n    while (merged) {\n        merged = false;\n        for (let i = 0; i < intervals.length; i++) {\n            for (let j = i + 1; j < intervals.length; j++) {\n                const [start1, end1] = intervals[i];\n                const [start2, end2] = intervals[j];\n                // Comprobar superposición\n                if (Math.max(start1, start2) <= Math.min(end1, end2)) {\n                    const newInterval = [Math.min(start1, start2), Math.max(end1, end2)];\n                    intervals.splice(j, 1);\n                    intervals.splice(i, 1);\n                    intervals.push(newInterval);\n                    merged = true;\n                    // Romper bucles para reiniciar la búsqueda\n                    break;\n                }\n            }\n            if (merged) break;\n        }\n    }\n    return intervals;\n}",
                "complexity": "Time: O(N^2) o peor, Space: O(1) [modifica in-place]",
                "example": {
                    "input": "[[1,4],[0,4]]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[[1,4],[0,4]]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[[1,4],[0,4]]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[[1,4],[0,4]]",
                                "result": "[[0,4]]"
                            },
                            "code_line": "return resultado",
                            "output": "[[0,4]]"
                        }
                    ],
                    "final_output": "[[0,4]]"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Basada en Grafos (Componentes Conectados)",
                "explanation": "Un enfoque conceptualmente diferente. Podemos modelar el problema como la búsqueda de componentes conectados en un grafo. Cada intervalo es un nodo. Existe una arista entre dos nodos si sus intervalos se superponen. El problema se reduce a encontrar los componentes conectados. Para cada componente, el intervalo fusionado es `[min(inicios), max(finales)]` de todos los intervalos en ese componente.",
                "code_snippet": "// Código conceptual, requiere construir un grafo y ejecutar DFS/BFS.\nfunction merge(intervals) {\n    // 1. Construir un grafo: las aristas conectan intervalos que se superponen.\n    const graph = new Map();\n    for (let i = 0; i < intervals.length; i++) graph.set(i, []);\n    for (let i = 0; i < intervals.length; i++) {\n        for (let j = i + 1; j < intervals.length; j++) {\n            const [s1, e1] = intervals[i];\n            const [s2, e2] = intervals[j];\n            if (s1 <= e2 && s2 <= e1) {\n                graph.get(i).push(j);\n                graph.get(j).push(i);\n            }\n        }\n    }\n\n    // 2. Encontrar componentes conectados usando DFS/BFS.\n    const visited = new Set();\n    const result = [];\n    for (let i = 0; i < intervals.length; i++) {\n        if (!visited.has(i)) {\n            const componentNodes = [];\n            const stack = [i];\n            visited.add(i);\n            while (stack.length) {\n                const node = stack.pop();\n                componentNodes.push(node);\n                for (const neighbor of graph.get(node)) {\n                    if (!visited.has(neighbor)) {\n                        visited.add(neighbor);\n                        stack.push(neighbor);\n                    }\n                }\n            }\n            // 3. Fusionar cada componente.\n            let minStart = Infinity, maxEnd = -Infinity;\n            for (const nodeIndex of componentNodes) {\n                minStart = Math.min(minStart, intervals[nodeIndex][0]);\n                maxEnd = Math.max(maxEnd, intervals[nodeIndex][1]);\n            }\n            result.push([minStart, maxEnd]);\n        }\n    }\n    return result;\n}",
                "complexity": "Time: O(N^2) [para construir el grafo], Space: O(N^2) [para el grafo]",
                "example": {
                    "input": "[[1,3],[2,6],[8,10],[15,18]]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[[1,3],[2,6],[8,10],[15,18]]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[[1,3],[2,6],[8,10],[15,18]]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[[1,3],[2,6],[8,10],[15,18]]",
                                "result": "[[1,6],[8,10],[15,18]]"
                            },
                            "code_line": "return resultado",
                            "output": "[[1,6],[8,10],[15,18]]"
                        }
                    ],
                    "final_output": "[[1,6],[8,10],[15,18]]"
                }
            }
        ]
    },
    {
        "id": "number-of-islands",
        "title": "200. Number of Islands",
        "difficulty": "Medium",
        "description": "Dado una cuadrícula 2D `grid` de `m x n` que representa un mapa de '1's (tierra) y '0's (agua), devuelve el número de islas. Una isla está rodeada de agua y se forma conectando tierras adyacentes horizontal o verticalmente.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Búsqueda en Profundidad (DFS)",
                "explanation": "Iteramos sobre cada celda de la cuadrícula. Si encontramos una celda con '1' (tierra), incrementamos nuestro contador de islas. Luego, iniciamos una búsqueda en profundidad (DFS) desde esa celda para encontrar todas las partes conectadas de esa isla. Durante el DFS, cambiamos el valor de las celdas de tierra a '0' (o a otro marcador) para asegurarnos de que no las contemos de nuevo.",
                "code_snippet": "function numIslands(grid) {\n    if (!grid || grid.length === 0) return 0;\n    let count = 0;\n    const rows = grid.length;\n    const cols = grid[0].length;\n\n    function dfs(r, c) {\n        if (r < 0 || c < 0 || r >= rows || c >= cols || grid[r][c] === '0') {\n            return;\n        }\n        grid[r][c] = '0'; // 'Hundir' la tierra visitada\n        dfs(r + 1, c);\n        dfs(r - 1, c);\n        dfs(r, c + 1);\n        dfs(r, c - 1);\n    }\n\n    for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n            if (grid[r][c] === '1') {\n                count++;\n                dfs(r, c);\n            }\n        }\n    }\n    return count;\n}",
                "complexity": "Time: O(M * N), Space: O(M * N) [en el peor caso, por la pila de recursión]",
                "example": {
                    "input": "[[\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\"],[\"0\",\"0\",\"1\"]]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[[\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\"],[\"0\",\"0\",\"1\"]]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[[\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\"],[\"0\",\"0\",\"1\"]]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[[\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\"],[\"0\",\"0\",\"1\"]]",
                                "result": "2"
                            },
                            "code_line": "return resultado",
                            "output": "2"
                        }
                    ],
                    "final_output": "2"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Búsqueda en Anchura (BFS)",
                "explanation": "Similar al DFS, pero utiliza una cola para una búsqueda iterativa por niveles. Cuando encontramos tierra ('1'), incrementamos el contador, añadimos las coordenadas a una cola y la marcamos como visitada ('0'). Luego, mientras la cola no esté vacía, procesamos las celdas, añadiendo a sus vecinos de tierra no visitados a la cola y marcándolos.",
                "code_snippet": "function numIslands(grid) {\n    if (!grid || grid.length === 0) return 0;\n    let count = 0;\n    const rows = grid.length;\n    const cols = grid[0].length;\n\n    for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n            if (grid[r][c] === '1') {\n                count++;\n                const queue = [[r, c]];\n                grid[r][c] = '0'; // Marcar como visitado\n                while (queue.length > 0) {\n                    const [currR, currC] = queue.shift();\n                    const directions = [[0,1],[0,-1],[1,0],[-1,0]];\n                    for (const [dr, dc] of directions) {\n                        const newR = currR + dr, newC = currC + dc;\n                        if (newR >= 0 && newC >= 0 && newR < rows && newC < cols && grid[newR][newC] === '1') {\n                            queue.push([newR, newC]);\n                            grid[newR][newC] = '0';\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return count;\n}",
                "complexity": "Time: O(M * N), Space: O(min(M, N)) [por la cola]",
                "example": {
                    "input": "[[\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\"],[\"0\",\"0\",\"1\"]]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[[\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\"],[\"0\",\"0\",\"1\"]]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[[\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\"],[\"0\",\"0\",\"1\"]]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[[\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\"],[\"0\",\"0\",\"1\"]]",
                                "result": "2"
                            },
                            "code_line": "return resultado",
                            "output": "2"
                        }
                    ],
                    "final_output": "2"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Union-Find (Conjuntos Disjuntos)",
                "explanation": "Un enfoque avanzado y muy eficiente. Inicialmente, tratamos cada celda de tierra como una isla separada. Luego, iteramos sobre la cuadrícula. Para cada celda de tierra, miramos a sus vecinos (derecha y abajo). Si un vecino también es tierra, unimos los conjuntos a los que pertenecen las dos celdas. El número de operaciones de unión reduce el recuento total de islas. El resultado final es el número de conjuntos disjuntos.",
                "code_snippet": "// Se requiere una clase UnionFind\nclass UnionFind {\n  /* ... implementación con find, union y count ... */\n}\n\nfunction numIslands(grid) {\n    if (!grid || grid.length === 0) return 0;\n    const rows = grid.length;\n    const cols = grid[0].length;\n    const uf = new UnionFind(grid); // La clase maneja la inicialización\n\n    for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n            if (grid[r][c] === '1') {\n                const p = r * cols + c;\n                // Mirar vecino derecho\n                if (c + 1 < cols && grid[r][c+1] === '1') {\n                    uf.union(p, p + 1);\n                }\n                // Mirar vecino de abajo\n                if (r + 1 < rows && grid[r+1][c] === '1') {\n                    uf.union(p, p + cols);\n                }\n            }\n        }\n    }\n    return uf.getCount();\n}",
                "complexity": "Time: O(M * N * α(M*N)), donde α es la función Ackermann inversa (casi constante). Space: O(M * N)",
                "example": {
                    "input": "[[\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\"],[\"0\",\"0\",\"1\"]]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "[[\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\"],[\"0\",\"0\",\"1\"]]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "[[\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\"],[\"0\",\"0\",\"1\"]]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "[[\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\"],[\"0\",\"0\",\"1\"]]",
                                "result": "2"
                            },
                            "code_line": "return resultado",
                            "output": "2"
                        }
                    ],
                    "final_output": "2"
                }
            }
        ]
    },
    {
        "id": "lowest-common-ancestor-of-a-bst",
        "title": "235. Lowest Common Ancestor of a Binary Search Tree",
        "difficulty": "Easy",
        "description": "Dado un Árbol de Búsqueda Binario (BST), encuentra el Ancestro Común más Bajo (LCA) de dos nodos dados en el BST. El LCA se define como el nodo más bajo en el árbol que tiene tanto a `p` como a `q` como descendientes.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Recursiva",
                "explanation": "Este enfoque aprovecha la propiedad del BST. Comenzando desde la raíz, si los valores de `p` y `q` son ambos menores que el valor del nodo actual, el LCA debe estar en el subárbol izquierdo. Si ambos son mayores, debe estar en el derecho. Si los valores se dividen (uno es mayor y otro menor), o si uno de los valores coincide con el nodo actual, entonces el nodo actual es el LCA.",
                "code_snippet": "function lowestCommonAncestor(root, p, q) {\n    const parentVal = root.val;\n    const pVal = p.val;\n    const qVal = q.val;\n\n    if (pVal > parentVal && qVal > parentVal) {\n        // Ambos están en el subárbol derecho\n        return lowestCommonAncestor(root.right, p, q);\n    } else if (pVal < parentVal && qVal < parentVal) {\n        // Ambos están en el subárbol izquierdo\n        return lowestCommonAncestor(root.left, p, q);\n    } else {\n        // Se han dividido o uno es la raíz, así que este nodo es el LCA\n        return root;\n    }\n}",
                "complexity": "Time: O(H) [Altura del árbol], Space: O(H) [por la pila de recursión]",
                "example": {
                    "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8",
                                "result": "6"
                            },
                            "code_line": "return resultado",
                            "output": "6"
                        }
                    ],
                    "final_output": "6"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Iterativa",
                "explanation": "La misma lógica que la solución recursiva, pero implementada con un bucle `while` para evitar la sobrecarga de la recursión y usar espacio O(1). Comenzamos con un puntero en la raíz y lo movemos hacia la izquierda o hacia la derecha basándonos en si los valores de `p` y `q` son mayores o menores que el valor del nodo del puntero. El bucle se detiene cuando encontramos el nodo de división, que es el LCA.",
                "code_snippet": "function lowestCommonAncestor(root, p, q) {\n    let node = root;\n    const pVal = p.val;\n    const qVal = q.val;\n\n    while (node) {\n        const parentVal = node.val;\n        if (pVal > parentVal && qVal > parentVal) {\n            node = node.right;\n        } else if (pVal < parentVal && qVal < parentVal) {\n            node = node.left;\n        } else {\n            return node;\n        }\n    }\n    return null;\n}",
                "complexity": "Time: O(H), Space: O(1)",
                "example": {
                    "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4",
                                "result": "2"
                            },
                            "code_line": "return resultado",
                            "output": "2"
                        }
                    ],
                    "final_output": "2"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Encontrando Caminos",
                "explanation": "Este es un enfoque más general que funcionaría para cualquier árbol binario, no solo BSTs. Primero, encontramos el camino desde la raíz hasta el nodo `p` y lo almacenamos. Luego, encontramos el camino desde la raíz hasta el nodo `q`. Finalmente, comparamos los dos caminos. El último nodo que tienen en común es el LCA. Este método es menos eficiente para un BST ya que no utiliza sus propiedades.",
                "code_snippet": "function lowestCommonAncestor(root, p, q) {\n    const getPath = (node, target) => {\n        const path = [];\n        while (node.val !== target.val) {\n            path.push(node);\n            if (target.val < node.val) {\n                node = node.left;\n            } else {\n                node = node.right;\n            }\n        }\n        path.push(node);\n        return path;\n    };\n\n    const pathP = getPath(root, p);\n    const pathQ = getPath(root, q);\n\n    let lca = null;\n    for (let i = 0; i < Math.min(pathP.length, pathQ.length); i++) {\n        if (pathP[i] === pathQ[i]) {\n            lca = pathP[i];\n        } else {\n            break;\n        }\n    }\n    return lca;\n}",
                "complexity": "Time: O(H), Space: O(H)",
                "example": {
                    "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4",
                                "result": "2"
                            },
                            "code_line": "return resultado",
                            "output": "2"
                        }
                    ],
                    "final_output": "2"
                }
            }
        ]
    },
    {
        "id": "coin-change",
        "title": "322. Coin Change",
        "difficulty": "Medium",
        "description": "Se te da un array de enteros `coins` que representan monedas de diferentes denominaciones y un entero `amount` que representa una cantidad total de dinero. Devuelve el menor número de monedas que necesitas para formar esa cantidad. Si esa cantidad no se puede formar con ninguna combinación de monedas, devuelve -1.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Programación Dinámica (Bottom-Up)",
                "explanation": "Este es el enfoque clásico de DP. Creamos un array `dp` de tamaño `amount + 1`, donde `dp[i]` almacenará el número mínimo de monedas para la cantidad `i`. Lo inicializamos con un valor grande (infinito). `dp[0]` es 0. Luego, iteramos desde 1 hasta `amount`. Para cada cantidad `i`, probamos cada moneda `c`. Si `i >= c`, entonces `dp[i] = min(dp[i], 1 + dp[i - c])`.",
                "code_snippet": "function coinChange(coins, amount) {\n    const dp = new Array(amount + 1).fill(Infinity);\n    dp[0] = 0;\n\n    for (let i = 1; i <= amount; i++) {\n        for (const coin of coins) {\n            if (i - coin >= 0) {\n                dp[i] = Math.min(dp[i], 1 + dp[i - coin]);\n            }\n        }\n    }\n\n    return dp[amount] === Infinity ? -1 : dp[amount];\n}",
                "complexity": "Time: O(Amount * N), donde N es el número de monedas. Space: O(Amount)",
                "example": {
                    "input": "coins = [1, 2, 5], amount = 11",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "coins = [1, 2, 5], amount = 11"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "coins = [1, 2, 5], amount = 11",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "coins = [1, 2, 5], amount = 11",
                                "result": "3 (5 + 5 + 1)"
                            },
                            "code_line": "return resultado",
                            "output": "3 (5 + 5 + 1)"
                        }
                    ],
                    "final_output": "3 (5 + 5 + 1)"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Programación Dinámica (Top-Down con Memoización)",
                "explanation": "Este es el enfoque recursivo optimizado. Definimos una función recursiva que calcula la cantidad mínima de monedas para una cantidad dada. Para evitar volver a calcular los mismos subproblemas, usamos un array o mapa de memoización (`memo`) para almacenar los resultados. Si `memo[amount]` ya está calculado, lo devolvemos directamente.",
                "code_snippet": "function coinChange(coins, amount) {\n    const memo = new Map();\n\n    function findMinCoins(rem) {\n        if (rem < 0) return Infinity;\n        if (rem === 0) return 0;\n        if (memo.has(rem)) return memo.get(rem);\n\n        let minCount = Infinity;\n        for (const coin of coins) {\n            const res = findMinCoins(rem - coin);\n            if (res !== Infinity) {\n                minCount = Math.min(minCount, 1 + res);\n            }\n        }\n\n        memo.set(rem, minCount);\n        return minCount;\n    }\n\n    const result = findMinCoins(amount);\n    return result === Infinity ? -1 : result;\n}",
                "complexity": "Time: O(Amount * N), Space: O(Amount)",
                "example": {
                    "input": "coins = [2], amount = 3",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "coins = [2], amount = 3"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "coins = [2], amount = 3",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "coins = [2], amount = 3",
                                "result": "-1"
                            },
                            "code_line": "return resultado",
                            "output": "-1"
                        }
                    ],
                    "final_output": "-1"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Búsqueda en Anchura (BFS)",
                "explanation": "Podemos ver este problema como la búsqueda del camino más corto en un grafo no ponderado. Cada cantidad de 0 a `amount` es un nodo. Hay una arista de `u` a `v` si `v = u + c` para alguna moneda `c`. Queremos encontrar el camino más corto desde el nodo 0 al nodo `amount`. El BFS es perfecto para esto. El nivel en el que encontramos `amount` por primera vez es la respuesta.",
                "code_snippet": "function coinChange(coins, amount) {\n    if (amount === 0) return 0;\n\n    const queue = [0];\n    const visited = new Set([0]);\n    let level = 0;\n\n    while (queue.length > 0) {\n        level++;\n        const levelSize = queue.length;\n        for (let i = 0; i < levelSize; i++) {\n            const currentAmount = queue.shift();\n            for (const coin of coins) {\n                const nextAmount = currentAmount + coin;\n                if (nextAmount === amount) return level;\n                if (nextAmount < amount && !visited.has(nextAmount)) {\n                    visited.add(nextAmount);\n                    queue.push(nextAmount);\n                }\n            }\n        }\n    }\n\n    return -1;\n}",
                "complexity": "Time: O(Amount * N), Space: O(Amount)",
                "example": {
                    "input": "coins = [1, 2, 5], amount = 11",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "coins = [1, 2, 5], amount = 11"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "coins = [1, 2, 5], amount = 11",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "coins = [1, 2, 5], amount = 11",
                                "result": "3"
                            },
                            "code_line": "return resultado",
                            "output": "3"
                        }
                    ],
                    "final_output": "3"
                }
            }
        ]
    },
    {
        "id": "path-sum",
        "title": "112. Path Sum",
        "difficulty": "Easy",
        "description": "Dado el `root` de un árbol binario y un entero `targetSum`, devuelve `true` si el árbol tiene una ruta de la raíz a la hoja tal que la suma de todos los valores a lo largo de la ruta sea igual a `targetSum`. Una hoja es un nodo sin hijos.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Recursión (DFS)",
                "explanation": "La forma más intuitiva de resolver este problema. Creamos una función recursiva que viaja por el árbol. En cada nodo, restamos su valor de la suma objetivo. El caso base es cuando llegamos a un nodo hoja (sin hijos izquierdo ni derecho). En ese punto, comprobamos si la suma restante es igual al valor de la hoja. Si no es una hoja, llamamos recursivamente a sus hijos con la suma actualizada.",
                "code_snippet": "function hasPathSum(root, targetSum) {\n    if (!root) return false;\n\n    // Si es un nodo hoja\n    if (!root.left && !root.right) {\n        return targetSum === root.val;\n    }\n\n    // Llamadas recursivas para los subárboles\n    const remainingSum = targetSum - root.val;\n    return hasPathSum(root.left, remainingSum) || hasPathSum(root.right, remainingSum);\n}",
                "complexity": "Time: O(N), Space: O(H) [Altura del árbol]",
                "example": {
                    "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22",
                                "result": "true (5->4->11->2)"
                            },
                            "code_line": "return resultado",
                            "output": "true (5->4->11->2)"
                        }
                    ],
                    "final_output": "true (5->4->11->2)"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Iterativa con Pila (DFS)",
                "explanation": "Podemos simular la recursión DFS usando una pila explícita. La pila almacenará pares `[nodo, suma_actual]`. Empezamos empujando la raíz y su valor. En cada iteración, sacamos un nodo y su suma. Si es una hoja y la suma coincide con `targetSum`, devolvemos `true`. De lo contrario, empujamos a sus hijos (si existen) a la pila con la suma actualizada.",
                "code_snippet": "function hasPathSum(root, targetSum) {\n    if (!root) return false;\n\n    const stack = [[root, root.val]];\n\n    while (stack.length > 0) {\n        const [node, currentSum] = stack.pop();\n\n        if (!node.left && !node.right && currentSum === targetSum) {\n            return true;\n        }\n\n        if (node.right) {\n            stack.push([node.right, currentSum + node.right.val]);\n        }\n        if (node.left) {\n            stack.push([node.left, currentSum + node.left.val]);\n        }\n    }\n    return false;\n}",
                "complexity": "Time: O(N), Space: O(H)",
                "example": {
                    "input": "root = [1,2,3], targetSum = 5",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "root = [1,2,3], targetSum = 5"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "root = [1,2,3], targetSum = 5",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "root = [1,2,3], targetSum = 5",
                                "result": "false"
                            },
                            "code_line": "return resultado",
                            "output": "false"
                        }
                    ],
                    "final_output": "false"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Iterativa con Cola (BFS)",
                "explanation": "Similar al enfoque iterativo DFS, pero usando una cola para un recorrido por niveles (BFS). La lógica es idéntica: la cola almacena pares `[nodo, suma_actual]`. Procesamos los nodos nivel por nivel. Este enfoque también encuentra una ruta válida, aunque no necesariamente la misma que encontraría DFS primero.",
                "code_snippet": "function hasPathSum(root, targetSum) {\n    if (!root) return false;\n\n    const queue = [[root, root.val]];\n\n    while (queue.length > 0) {\n        const [node, currentSum] = queue.shift();\n\n        if (!node.left && !node.right && currentSum === targetSum) {\n            return true;\n        }\n\n        if (node.left) {\n            queue.push([node.left, currentSum + node.left.val]);\n        }\n        if (node.right) {\n            queue.push([node.right, currentSum + node.right.val]);\n        }\n    }\n    return false;\n}",
                "complexity": "Time: O(N), Space: O(W) [Ancho máximo del árbol]",
                "example": {
                    "input": "root = [], targetSum = 0",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "root = [], targetSum = 0"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "root = [], targetSum = 0",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "root = [], targetSum = 0",
                                "result": "false"
                            },
                            "code_line": "return resultado",
                            "output": "false"
                        }
                    ],
                    "final_output": "false"
                }
            }
        ]
    },
    {
        "id": "same-tree",
        "title": "100. Same Tree",
        "difficulty": "Easy",
        "description": "Dadas las raíces de dos árboles binarios, `p` y `q`, escribe una función para comprobar si son iguales. Dos árboles binarios se consideran iguales si son estructuralmente idénticos y los nodos tienen el mismo valor.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Recursiva",
                "explanation": "El enfoque más simple y elegante. Comparamos los dos nodos actuales. Los casos base son: 1) Si ambos son nulos, son iguales. 2) Si uno es nulo pero el otro no, o si sus valores son diferentes, no son iguales. Si pasan estas comprobaciones, el resultado depende de si sus subárboles izquierdo y derecho son iguales, lo que verificamos con llamadas recursivas.",
                "code_snippet": "function isSameTree(p, q) {\n    // Si ambos son nulos, son iguales.\n    if (!p && !q) return true;\n    // Si uno es nulo o los valores no coinciden, no son iguales.\n    if (!p || !q || p.val !== q.val) return false;\n\n    // Comprobar recursivamente los subárboles.\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}",
                "complexity": "Time: O(N), Space: O(H) [Altura del árbol]",
                "example": {
                    "input": "p = [1,2,3], q = [1,2,3]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "p = [1,2,3], q = [1,2,3]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "p = [1,2,3], q = [1,2,3]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "p = [1,2,3], q = [1,2,3]",
                                "result": "true"
                            },
                            "code_line": "return resultado",
                            "output": "true"
                        }
                    ],
                    "final_output": "true"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Iterativa con Cola (BFS)",
                "explanation": "Utilizamos una cola para comparar los árboles nivel por nivel. Añadimos ambas raíces a la cola. Mientras la cola no esté vacía, sacamos dos nodos (`nodeP`, `nodeQ`) y los comparamos. Si son iguales, añadimos sus hijos a la cola en el mismo orden (`p.left` con `q.left`, `p.right` con `q.right`) para la siguiente ronda de comparaciones.",
                "code_snippet": "function isSameTree(p, q) {\n    const queue = [p, q];\n\n    while (queue.length > 0) {\n        const nodeP = queue.shift();\n        const nodeQ = queue.shift();\n\n        if (!nodeP && !nodeQ) continue;\n        if (!nodeP || !nodeQ || nodeP.val !== nodeQ.val) return false;\n\n        queue.push(nodeP.left);\n        queue.push(nodeQ.left);\n        queue.push(nodeP.right);\n        queue.push(nodeQ.right);\n    }\n    return true;\n}",
                "complexity": "Time: O(N), Space: O(W) [Ancho máximo del árbol]",
                "example": {
                    "input": "p = [1,2], q = [1,null,2]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "p = [1,2], q = [1,null,2]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "p = [1,2], q = [1,null,2]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "p = [1,2], q = [1,null,2]",
                                "result": "false"
                            },
                            "code_line": "return resultado",
                            "output": "false"
                        }
                    ],
                    "final_output": "false"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Iterativa con Pila (DFS)",
                "explanation": "Similar a la solución con cola, pero utilizando una pila para un recorrido en profundidad. La lógica es la misma: la pila almacena pares de nodos a comparar. Sacamos dos nodos, los validamos, y si son válidos, empujamos a sus hijos a la pila para ser comparados más tarde.",
                "code_snippet": "function isSameTree(p, q) {\n    const stack = [p, q];\n\n    while (stack.length > 0) {\n        const nodeQ = stack.pop();\n        const nodeP = stack.pop();\n\n        if (!nodeP && !nodeQ) continue;\n        if (!nodeP || !nodeQ || nodeP.val !== nodeQ.val) return false;\n\n        stack.push(nodeP.left);\n        stack.push(nodeQ.left);\n        stack.push(nodeP.right);\n        stack.push(nodeQ.right);\n    }\n    return true;\n}",
                "complexity": "Time: O(N), Space: O(H)",
                "example": {
                    "input": "p = [1,2,1], q = [1,1,2]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "p = [1,2,1], q = [1,1,2]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "p = [1,2,1], q = [1,1,2]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "p = [1,2,1], q = [1,1,2]",
                                "result": "false"
                            },
                            "code_line": "return resultado",
                            "output": "false"
                        }
                    ],
                    "final_output": "false"
                }
            }
        ]
    },
    {
        "id": "plus-one",
        "title": "066. Plus One",
        "difficulty": "Easy",
        "description": "Se te da un array de dígitos que representa un gran entero. Los dígitos se ordenan del más al menos significativo. Incrementa el gran entero en uno y devuelve el array de dígitos resultante.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Iteración desde el Final (Clásica)",
                "explanation": "Recorremos el array de dígitos de derecha a izquierda. Si un dígito es menor que 9, simplemente lo incrementamos y devolvemos el array. Si es 9, lo cambiamos a 0 y continuamos con el 'acarreo' (carry) a la siguiente posición. Si todo el array son nueves (ej. [9,9]), el bucle terminará y tendremos que añadir un 1 al principio del array.",
                "code_snippet": "function plusOne(digits) {\n    for (let i = digits.length - 1; i >= 0; i--) {\n        if (digits[i] < 9) {\n            digits[i]++;\n            return digits;\n        }\n        digits[i] = 0;\n    }\n    // Si salimos del bucle, significa que todos los dígitos eran 9\n    digits.unshift(1);\n    return digits;\n}",
                "complexity": "Time: O(N), Space: O(1) [O(N) en el peor caso por unshift]",
                "example": {
                    "input": "digits = [4,3,2,1]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "digits = [4,3,2,1]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "digits = [4,3,2,1]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "digits = [4,3,2,1]",
                                "result": "[4,3,2,2]"
                            },
                            "code_line": "return resultado",
                            "output": "[4,3,2,2]"
                        }
                    ],
                    "final_output": "[4,3,2,2]"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Conversión a BigInt",
                "explanation": "Un enfoque directo que aprovecha las capacidades del lenguaje. Convertimos el array de dígitos a una cadena, luego a un `BigInt` (para manejar números muy grandes), le sumamos 1, lo convertimos de nuevo a una cadena y finalmente dividimos la cadena en un array de dígitos numéricos. Es simple pero puede ser menos eficiente para arrays extremadamente grandes.",
                "code_snippet": "function plusOne(digits) {\n    const numAsString = digits.join('');\n    const bigNum = BigInt(numAsString);\n    const resultNum = bigNum + 1n;\n    return resultNum.toString().split('').map(Number);\n}",
                "complexity": "Time: O(N), Space: O(N)",
                "example": {
                    "input": "digits = [9,9,9]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "digits = [9,9,9]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "digits = [9,9,9]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "digits = [9,9,9]",
                                "result": "[1,0,0,0]"
                            },
                            "code_line": "return resultado",
                            "output": "[1,0,0,0]"
                        }
                    ],
                    "final_output": "[1,0,0,0]"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Recursiva",
                "explanation": "Podemos usar la recursión para manejar el acarreo. Una función auxiliar toma un índice. Intenta sumar uno en esa posición. Si el dígito se convierte en 10, lo establece en 0 y hace una llamada recursiva para el índice anterior (`index - 1`). El caso base es cuando un dígito no necesita acarreo o cuando el acarreo sale del inicio del array.",
                "code_snippet": "function plusOne(digits) {\n    function add(index) {\n        if (index < 0) {\n            digits.unshift(1);\n            return;\n        }\n        digits[index]++;\n        if (digits[index] === 10) {\n            digits[index] = 0;\n            add(index - 1);\n        }\n    }\n    add(digits.length - 1);\n    return digits;\n}",
                "complexity": "Time: O(N), Space: O(N) [por la pila de recursión]",
                "example": {
                    "input": "digits = [1,2,3]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "digits = [1,2,3]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "digits = [1,2,3]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "digits = [1,2,3]",
                                "result": "[1,2,4]"
                            },
                            "code_line": "return resultado",
                            "output": "[1,2,4]"
                        }
                    ],
                    "final_output": "[1,2,4]"
                }
            }
        ]
    },
    {
        "id": "sqrt-x",
        "title": "069. Sqrt(x)",
        "difficulty": "Easy",
        "description": "Dado un entero no negativo `x`, calcula y devuelve la raíz cuadrada de `x`. Como el tipo de retorno es un entero, la parte decimal se trunca. No puedes usar funciones de exponente integradas.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Búsqueda Binaria",
                "explanation": "La solución más eficiente y estándar. Sabemos que la raíz cuadrada de `x` debe estar en el rango de `[0, x]`. Podemos aplicar búsqueda binaria en este rango. Para cada valor `mid`, comprobamos si `mid * mid` es igual, mayor o menor que `x`. Ajustamos nuestro rango de búsqueda (`left`, `right`) en consecuencia hasta que encontremos el mayor entero cuya raíz cuadrada sea menor o igual a `x`.",
                "code_snippet": "function mySqrt(x) {\n    if (x < 2) return x;\n    let left = 1, right = x, ans = 0;\n\n    while (left <= right) {\n        let mid = Math.floor(left + (right - left) / 2);\n        // Usar división para evitar desbordamiento con mid*mid\n        if (mid <= x / mid) {\n            ans = mid; // Este es un candidato válido\n            left = mid + 1; // Intentar encontrar uno más grande\n        } else {\n            right = mid - 1;\n        }\n    }\n    return ans;\n}",
                "complexity": "Time: O(log N), Space: O(1)",
                "example": {
                    "input": "8",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "8"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "8",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "8",
                                "result": "2"
                            },
                            "code_line": "return resultado",
                            "output": "2"
                        }
                    ],
                    "final_output": "2"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Método de Newton",
                "explanation": "Un método numérico clásico para encontrar raíces. Para encontrar `sqrt(x)`, buscamos la raíz de la función `f(r) = r^2 - x`. La fórmula de iteración es `r_nuevo = (r_viejo + x / r_viejo) / 2`. Comenzamos con una suposición inicial (ej. `x`) y aplicamos la fórmula repetidamente hasta que el valor converja. La convergencia es muy rápida.",
                "code_snippet": "function mySqrt(x) {\n    if (x === 0) return 0;\n    let r = x;\n    while (r * r > x) {\n        r = Math.floor((r + x / r) / 2);\n    }\n    return r;\n}",
                "complexity": "Time: O(log N) [la convergencia es cuadrática], Space: O(1)",
                "example": {
                    "input": "4",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "4"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "4",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "4",
                                "result": "2"
                            },
                            "code_line": "return resultado",
                            "output": "2"
                        }
                    ],
                    "final_output": "2"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Fuerza Bruta",
                "explanation": "La solución más simple pero ineficiente. Iteramos con un número `i` desde 0 hacia arriba. En cada paso, comprobamos si `i * i` es mayor que `x`. Tan pronto como lo sea, sabemos que el `i` anterior fue la respuesta entera correcta. Este enfoque es demasiado lento para números grandes.",
                "code_snippet": "function mySqrt(x) {\n    if (x < 2) return x;\n    for (let i = 1; i <= x; i++) {\n        if (i * i > x) {\n            return i - 1;\n        }\n        if (i * i === x) {\n            return i;\n        }\n    }\n}",
                "complexity": "Time: O(sqrt(N)), Space: O(1)",
                "example": {
                    "input": "9",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "9"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "9",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "9",
                                "result": "3"
                            },
                            "code_line": "return resultado",
                            "output": "3"
                        }
                    ],
                    "final_output": "3"
                }
            }
        ]
    },
    {
        "id": "length-of-last-word",
        "title": "058. Length of Last Word",
        "difficulty": "Easy",
        "description": "Dada una cadena `s` que consiste en palabras y espacios, devuelve la longitud de la última palabra en la cadena. Una palabra es una subcadena máxima que consiste solo en caracteres que no son espacios.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Usando Métodos de String",
                "explanation": "La forma más idiomática en lenguajes de alto nivel. Primero, usamos `.trim()` para eliminar cualquier espacio en blanco al principio o al final. Luego, usamos `.split(' ')` para dividir la cadena en un array de palabras. La última palabra es el último elemento del array, y simplemente devolvemos su longitud.",
                "code_snippet": "function lengthOfLastWord(s) {\n    const words = s.trim().split(' ');\n    return words[words.length - 1].length;\n}",
                "complexity": "Time: O(N), Space: O(N) [para el array de palabras]",
                "example": {
                    "input": "s = \"Hello World\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "s = \"Hello World\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "s = \"Hello World\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "s = \"Hello World\"",
                                "result": "5"
                            },
                            "code_line": "return resultado",
                            "output": "5"
                        }
                    ],
                    "final_output": "5"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Búsqueda desde el Final (Óptima)",
                "explanation": "Este enfoque es más eficiente en espacio. Iteramos la cadena desde el final. Primero, usamos un bucle para saltar cualquier espacio en blanco final. Una vez que encontramos el primer carácter que no es un espacio, comenzamos a contar hasta que encontramos otro espacio o llegamos al principio de la cadena. Este conteo es la longitud de la última palabra.",
                "code_snippet": "function lengthOfLastWord(s) {\n    let length = 0;\n    let i = s.length - 1;\n\n    // Saltar espacios finales\n    while (i >= 0 && s[i] === ' ') {\n        i--;\n    }\n\n    // Contar la última palabra\n    while (i >= 0 && s[i] !== ' ') {\n        length++;\n        i--;\n    }\n    return length;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "s = \"   fly me   to   the moon  \"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "s = \"   fly me   to   the moon  \""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "s = \"   fly me   to   the moon  \"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "s = \"   fly me   to   the moon  \"",
                                "result": "4"
                            },
                            "code_line": "return resultado",
                            "output": "4"
                        }
                    ],
                    "final_output": "4"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Usando `lastIndexOf`",
                "explanation": "Otra forma de usar métodos de string integrados. Primero, usamos `.trim()` para limpiar la cadena. Luego, encontramos el índice del último espacio con `lastIndexOf(' ')`. La longitud de la última palabra es la longitud total de la cadena recortada menos la posición del último espacio menos 1.",
                "code_snippet": "function lengthOfLastWord(s) {\n    const trimmed = s.trim();\n    const lastSpaceIndex = trimmed.lastIndexOf(' ');\n    return trimmed.length - lastSpaceIndex - 1;\n}",
                "complexity": "Time: O(N), Space: O(N) [por la nueva cadena de trim]",
                "example": {
                    "input": "s = \"luffy is still joyboy\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "s = \"luffy is still joyboy\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "s = \"luffy is still joyboy\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "s = \"luffy is still joyboy\"",
                                "result": "6"
                            },
                            "code_line": "return resultado",
                            "output": "6"
                        }
                    ],
                    "final_output": "6"
                }
            }
        ]
    },
    {
        "id": "intersection-of-two-linked-lists",
        "title": "160. Intersection of Two Linked Lists",
        "difficulty": "Easy",
        "description": "Dadas las cabezas de dos listas enlazadas simples, `headA` y `headB`, devuelve el nodo en el que las dos listas se cruzan. Si las dos listas no se cruzan, devuelve `null`.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Two Pointers (Óptima)",
                "explanation": "La solución más ingeniosa y eficiente. Usamos dos punteros, `pA` y `pB`, que comienzan en `headA` y `headB`. Ambos recorren sus listas. Cuando uno llega al final, salta a la cabeza de la *otra* lista. De esta manera, ambos punteros recorren la misma distancia total (`lenA + lenB`). Si hay una intersección, se encontrarán en el nodo de intersección. Si no, se encontrarán en `null` al final.",
                "code_snippet": "function getIntersectionNode(headA, headB) {\n    if (!headA || !headB) return null;\n\n    let pA = headA;\n    let pB = headB;\n\n    while (pA !== pB) {\n        pA = (pA === null) ? headB : pA.next;\n        pB = (pB === null) ? headA : pB.next;\n    }\n    return pA; // O pB, serán el mismo nodo o null\n}",
                "complexity": "Time: O(M + N), Space: O(1)",
                "example": {
                    "input": "listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], intersectVal = 8",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], intersectVal = 8"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], intersectVal = 8",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], intersectVal = 8",
                                "result": "Nodo con valor 8"
                            },
                            "code_line": "return resultado",
                            "output": "Nodo con valor 8"
                        }
                    ],
                    "final_output": "Nodo con valor 8"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Hash Set",
                "explanation": "Un enfoque intuitivo que utiliza espacio extra. Primero, recorremos una de las listas (por ejemplo, `listA`) y almacenamos cada nodo visitado en un `Set`. Luego, recorremos la segunda lista (`listB`). Para cada nodo de `listB`, comprobamos si ya existe en el `Set`. El primer nodo que encontremos en el `Set` es el punto de intersección.",
                "code_snippet": "function getIntersectionNode(headA, headB) {\n    const visited = new Set();\n\n    let current = headA;\n    while (current) {\n        visited.add(current);\n        current = current.next;\n    }\n\n    current = headB;\n    while (current) {\n        if (visited.has(current)) {\n            return current;\n        }\n        current = current.next;\n    }\n\n    return null;\n}",
                "complexity": "Time: O(M + N), Space: O(M) o O(N)",
                "example": {
                    "input": "listA = [1,9,1,2,4], listB = [3,2,4], intersectVal = 2",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "listA = [1,9,1,2,4], listB = [3,2,4], intersectVal = 2"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "listA = [1,9,1,2,4], listB = [3,2,4], intersectVal = 2",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "listA = [1,9,1,2,4], listB = [3,2,4], intersectVal = 2",
                                "result": "Nodo con valor 2"
                            },
                            "code_line": "return resultado",
                            "output": "Nodo con valor 2"
                        }
                    ],
                    "final_output": "Nodo con valor 2"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Fuerza Bruta",
                "explanation": "La solución más simple conceptualmente pero la menos eficiente. Por cada nodo en la `listA`, recorremos la `listB` completa desde su cabeza para ver si algún nodo coincide. Si encontramos una coincidencia de referencias de nodo, hemos encontrado la intersección. Este enfoque tiene una complejidad cuadrática.",
                "code_snippet": "function getIntersectionNode(headA, headB) {\n    let pA = headA;\n    while (pA) {\n        let pB = headB;\n        while (pB) {\n            if (pA === pB) {\n                return pA;\n            }\n            pB = pB.next;\n        }\n        pA = pA.next;\n    }\n    return null;\n}",
                "complexity": "Time: O(M * N), Space: O(1)",
                "example": {
                    "input": "listA = [2,6,4], listB = [1,5], intersectVal = 0",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "listA = [2,6,4], listB = [1,5], intersectVal = 0"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "listA = [2,6,4], listB = [1,5], intersectVal = 0",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "listA = [2,6,4], listB = [1,5], intersectVal = 0",
                                "result": "null"
                            },
                            "code_line": "return resultado",
                            "output": "null"
                        }
                    ],
                    "final_output": "null"
                }
            }
        ]
    },
    {
        "id": "excel-sheet-column-number",
        "title": "171. Excel Sheet Column Number",
        "difficulty": "Easy",
        "description": "Dada una cadena `columnTitle` que representa el título de una columna como aparece en una hoja de Excel, devuelve su número de columna correspondiente. Por ejemplo, `A -> 1`, `B -> 2`, `Z -> 26`, `AA -> 27`, `AB -> 28`.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Iteración de Izquierda a Derecha",
                "explanation": "Este problema es equivalente a convertir un número en base 26 a base 10. Iteramos a través de la cadena de izquierda a derecha. En cada paso, multiplicamos el resultado acumulado por 26 y le sumamos el valor del carácter actual. El valor de un carácter se calcula como `(su código ASCII - código ASCII de 'A' + 1)`.",
                "code_snippet": "function titleToNumber(columnTitle) {\n    let result = 0;\n    const base = 'A'.charCodeAt(0) - 1;\n\n    for (const char of columnTitle) {\n        result = result * 26 + (char.charCodeAt(0) - base);\n    }\n    return result;\n}",
                "complexity": "Time: O(N), donde N es la longitud del título. Space: O(1)",
                "example": {
                    "input": "\"AB\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "\"AB\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "\"AB\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "\"AB\"",
                                "result": "28"
                            },
                            "code_line": "return resultado",
                            "output": "28"
                        }
                    ],
                    "final_output": "28"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Iteración de Derecha a Izquierda",
                "explanation": "Este enfoque imita más de cerca cómo calculamos manualmente los valores en un sistema de bases. Iteramos desde el final de la cadena hacia el principio. Mantenemos una variable `powerOf26` que comienza en 1. En cada paso, calculamos el valor del carácter, lo multiplicamos por `powerOf26` y lo sumamos al resultado. Luego, multiplicamos `powerOf26` por 26 para la siguiente iteración.",
                "code_snippet": "function titleToNumber(columnTitle) {\n    let result = 0;\n    let powerOf26 = 1;\n    const base = 'A'.charCodeAt(0) - 1;\n\n    for (let i = columnTitle.length - 1; i >= 0; i--) {\n        const charVal = columnTitle.charCodeAt(i) - base;\n        result += charVal * powerOf26;\n        powerOf26 *= 26;\n    }\n    return result;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "\"ZY\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "\"ZY\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "\"ZY\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "\"ZY\"",
                                "result": "701"
                            },
                            "code_line": "return resultado",
                            "output": "701"
                        }
                    ],
                    "final_output": "701"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Funcional con `reduce`",
                "explanation": "Una forma más concisa y funcional de escribir la lógica de izquierda a derecha en JavaScript. Convertimos la cadena en un array de caracteres y usamos el método `reduce`. El acumulador (`acc`) representa el resultado hasta el momento, que se multiplica por 26 en cada paso antes de sumar el valor del carácter actual.",
                "code_snippet": "function titleToNumber(columnTitle) {\n    const base = 'A'.charCodeAt(0) - 1;\n    return columnTitle.split('').reduce((acc, char) => {\n        return acc * 26 + (char.charCodeAt(0) - base);\n    }, 0);\n}",
                "complexity": "Time: O(N), Space: O(N) [por el array intermedio de split]",
                "example": {
                    "input": "\"A\"",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "\"A\""
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "\"A\"",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "\"A\"",
                                "result": "1"
                            },
                            "code_line": "return resultado",
                            "output": "1"
                        }
                    ],
                    "final_output": "1"
                }
            }
        ]
    },
    {
        "id": "pascals-triangle",
        "title": "118. Pascal's Triangle",
        "difficulty": "Easy",
        "description": "Dado un entero `numRows`, genera las primeras `numRows` del Triángulo de Pascal. En el Triángulo de Pascal, cada número es la suma de los dos números directamente encima de él.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Simulación Iterativa",
                "explanation": "Este es el enfoque más directo. Construimos el triángulo fila por fila. Empezamos con la primera fila `[1]`. Luego, en un bucle, generamos cada nueva fila basándonos en la fila anterior. Cada elemento de la nueva fila (excepto los extremos, que siempre son 1) es la suma de los dos elementos correspondientes de la fila anterior.",
                "code_snippet": "function generate(numRows) {\n    if (numRows === 0) return [];\n    const triangle = [[1]];\n\n    for (let i = 1; i < numRows; i++) {\n        const prevRow = triangle[i - 1];\n        const newRow = [1];\n        for (let j = 1; j < prevRow.length; j++) {\n            newRow.push(prevRow[j - 1] + prevRow[j]);\n        }\n        newRow.push(1);\n        triangle.push(newRow);\n    }\n    return triangle;\n}",
                "complexity": "Time: O(numRows^2), Space: O(numRows^2)",
                "example": {
                    "input": "numRows = 5",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "numRows = 5"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "numRows = 5",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "numRows = 5",
                                "result": "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]"
                            },
                            "code_line": "return resultado",
                            "output": "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]"
                        }
                    ],
                    "final_output": "[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Usando la Fórmula Matemática",
                "explanation": "Cada elemento en el Triángulo de Pascal en la fila `n` y columna `k` es `C(n, k)`, el coeficiente binomial. Podemos calcular cada elemento de una fila a partir del anterior. El primer elemento de una fila es `C(n, 0) = 1`. El siguiente es `C(n, 1) = C(n, 0) * (n - 0) / 1`. En general, `C(n, k) = C(n, k-1) * (n - k + 1) / k`. Esto evita recalcular todo desde la fila anterior.",
                "code_snippet": "function generate(numRows) {\n    const triangle = [];\n    for (let i = 0; i < numRows; i++) {\n        const row = [1];\n        let current = 1;\n        for (let j = 1; j <= i; j++) {\n            current = current * (i - j + 1) / j;\n            row.push(current);\n        }\n        triangle.push(row);\n    }\n    return triangle;\n}",
                "complexity": "Time: O(numRows^2), Space: O(numRows^2)",
                "example": {
                    "input": "numRows = 3",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "numRows = 3"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "numRows = 3",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "numRows = 3",
                                "result": "[[1],[1,1],[1,2,1]]"
                            },
                            "code_line": "return resultado",
                            "output": "[[1],[1,1],[1,2,1]]"
                        }
                    ],
                    "final_output": "[[1],[1,1],[1,2,1]]"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Recursiva",
                "explanation": "Podemos definir el problema de forma recursiva. Para generar `n` filas, primero generamos `n-1` filas recursivamente, y luego construimos la `n`-ésima fila a partir de la última fila obtenida en la llamada recursiva. El caso base es cuando `numRows` es 1. Aunque es conceptualmente válido, es menos eficiente que el enfoque iterativo.",
                "code_snippet": "function generate(numRows) {\n    if (numRows === 1) return [[1]];\n    if (numRows === 0) return [];\n\n    const prevTriangle = generate(numRows - 1);\n    const prevRow = prevTriangle[prevTriangle.length - 1];\n    const newRow = [1];\n\n    for (let j = 1; j < prevRow.length; j++) {\n        newRow.push(prevRow[j - 1] + prevRow[j]);\n    }\n    newRow.push(1);\n\n    prevTriangle.push(newRow);\n    return prevTriangle;\n}",
                "complexity": "Time: O(numRows^2), Space: O(numRows^2)",
                "example": {
                    "input": "numRows = 1",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "numRows = 1"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "numRows = 1",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "numRows = 1",
                                "result": "[[1]]"
                            },
                            "code_line": "return resultado",
                            "output": "[[1]]"
                        }
                    ],
                    "final_output": "[[1]]"
                }
            }
        ]
    },
    {
        "id": "convert-sorted-array-to-binary-search-tree",
        "title": "108. Convert Sorted Array to Binary Search Tree",
        "difficulty": "Easy",
        "description": "Dado un array de enteros `nums` donde los elementos están ordenados en orden ascendente, conviértelo en un Árbol de Búsqueda Binario (BST) de altura balanceada.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Recursión (Pre-order Traversal)",
                "explanation": "La solución óptima y más natural. Para asegurar que el árbol esté balanceado, el elemento del medio del array debe ser la raíz del árbol. El subarray a la izquierda del medio formará el subárbol izquierdo, y el subarray a la derecha formará el subárbol derecho. Aplicamos esta lógica recursivamente a los subarrays.",
                "code_snippet": "function sortedArrayToBST(nums) {\n    if (!nums.length) return null;\n\n    function build(left, right) {\n        if (left > right) return null;\n\n        const mid = Math.floor(left + (right - left) / 2);\n        const node = new TreeNode(nums[mid]);\n        \n        node.left = build(left, mid - 1);\n        node.right = build(mid + 1, right);\n        \n        return node;\n    }\n\n    return build(0, nums.length - 1);\n}",
                "complexity": "Time: O(N), Space: O(log N) [por la pila de recursión]",
                "example": {
                    "input": "nums = [-10,-3,0,5,9]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "nums = [-10,-3,0,5,9]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "nums = [-10,-3,0,5,9]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "nums = [-10,-3,0,5,9]",
                                "result": "[0,-3,9,-10,null,5]"
                            },
                            "code_line": "return resultado",
                            "output": "[0,-3,9,-10,null,5]"
                        }
                    ],
                    "final_output": "[0,-3,9,-10,null,5]"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Iterativa con Pila",
                "explanation": "Podemos simular la recursión de forma iterativa usando una pila. La pila almacenará tuplas de `[nodo, límite_izquierdo, límite_derecho]`. Empezamos con la raíz y los límites del array completo. En cada paso, sacamos un elemento, calculamos el medio, asignamos el valor y luego empujamos los subproblemas izquierdo y derecho a la pila para su posterior procesamiento.",
                "code_snippet": "function sortedArrayToBST(nums) {\n    if (!nums.length) return null;\n\n    const root = new TreeNode();\n    const stack = [[root, 0, nums.length - 1]];\n\n    while (stack.length > 0) {\n        const [node, left, right] = stack.pop();\n        const mid = Math.floor(left + (right - left) / 2);\n        node.val = nums[mid];\n\n        if (left <= mid - 1) {\n            node.left = new TreeNode();\n            stack.push([node.left, left, mid - 1]);\n        }\n        if (mid + 1 <= right) {\n            node.right = new TreeNode();\n            stack.push([node.right, mid + 1, right]);\n        }\n    }\n    return root;\n}",
                "complexity": "Time: O(N), Space: O(N) [en el peor caso]",
                "example": {
                    "input": "nums = [1,3]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "nums = [1,3]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "nums = [1,3]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "nums = [1,3]",
                                "result": "[3,1] o [1,null,3]"
                            },
                            "code_line": "return resultado",
                            "output": "[3,1] o [1,null,3]"
                        }
                    ],
                    "final_output": "[3,1] o [1,null,3]"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Usando `slice` (Menos Eficiente)",
                "explanation": "Una variación de la solución recursiva que es más fácil de leer pero menos eficiente debido al uso de `slice`. En lugar de pasar índices, creamos nuevos subarrays para las llamadas recursivas. `slice` tiene un costo de O(K) donde K es el tamaño de la rebanada, lo que hace que la complejidad total del tiempo sea mayor.",
                "code_snippet": "function sortedArrayToBST(nums) {\n    if (!nums.length) return null;\n\n    const mid = Math.floor(nums.length / 2);\n    const root = new TreeNode(nums[mid]);\n\n    // slice crea nuevos arrays en cada llamada\n    root.left = sortedArrayToBST(nums.slice(0, mid));\n    root.right = sortedArrayToBST(nums.slice(mid + 1));\n\n    return root;\n}",
                "complexity": "Time: O(N log N) [debido a slice], Space: O(N) [por los nuevos arrays]",
                "example": {
                    "input": "nums = [-10,-3,0,5,9]",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "nums = [-10,-3,0,5,9]"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "nums = [-10,-3,0,5,9]",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "nums = [-10,-3,0,5,9]",
                                "result": "[0,-3,9,-10,null,5]"
                            },
                            "code_line": "return resultado",
                            "output": "[0,-3,9,-10,null,5]"
                        }
                    ],
                    "final_output": "[0,-3,9,-10,null,5]"
                }
            }
        ]
    },
    {
        "id": "search-insert-position",
        "title": "035. Search Insert Position",
        "difficulty": "Easy",
        "description": "Dado un array ordenado de enteros distintos y un valor objetivo, devuelve el índice si se encuentra el objetivo. Si no, devuelve el índice donde estaría si se insertara en orden.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Búsqueda Binaria",
                "explanation": "El enfoque óptimo. Utilizamos búsqueda binaria para encontrar el objetivo. Si lo encontramos, devolvemos su índice. Si el bucle termina sin encontrar el objetivo (`left > right`), el puntero `left` apuntará exactamente a la posición donde el objetivo debería insertarse para mantener el orden. Por lo tanto, simplemente devolvemos `left`.",
                "code_snippet": "function searchInsert(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n\n    while (left <= right) {\n        let mid = Math.floor(left + (right - left) / 2);\n        if (nums[mid] === target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    // Si no se encuentra, 'left' es la posición de inserción.\n    return left;\n}",
                "complexity": "Time: O(log N), Space: O(1)",
                "example": {
                    "input": "nums = [1,3,5,6], target = 5",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "nums = [1,3,5,6], target = 5"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "nums = [1,3,5,6], target = 5",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "nums = [1,3,5,6], target = 5",
                                "result": "2"
                            },
                            "code_line": "return resultado",
                            "output": "2"
                        }
                    ],
                    "final_output": "2"
                }
            },
            {
                "id": 2,
                "title": "Solución 2: Búsqueda Lineal",
                "explanation": "La solución de fuerza bruta. Recorremos el array desde el principio. Buscamos el primer elemento que sea igual o mayor que el objetivo. El índice de ese elemento es la respuesta. Si recorremos todo el array y todos los elementos son menores que el objetivo, la posición de inserción es al final del array (`nums.length`).",
                "code_snippet": "function searchInsert(nums, target) {\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] >= target) {\n            return i;\n        }\n    }\n    return nums.length;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "nums = [1,3,5,6], target = 2",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "nums = [1,3,5,6], target = 2"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "nums = [1,3,5,6], target = 2",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "nums = [1,3,5,6], target = 2",
                                "result": "1"
                            },
                            "code_line": "return resultado",
                            "output": "1"
                        }
                    ],
                    "final_output": "1"
                }
            },
            {
                "id": 3,
                "title": "Solución 3: Usando `findIndex`",
                "explanation": "Un enfoque funcional y conciso en JavaScript. El método `findIndex` devuelve el índice del primer elemento que satisface una condición. Buscamos el primer elemento que sea mayor o igual que el `target`. Si se encuentra, `findIndex` devuelve su índice. Si no se encuentra ningún elemento así (lo que significa que el `target` debe ir al final), `findIndex` devuelve -1. En ese caso, devolvemos la longitud del array.",
                "code_snippet": "function searchInsert(nums, target) {\n    const index = nums.findIndex(num => num >= target);\n    return index === -1 ? nums.length : index;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": {
                    "input": "nums = [1,3,5,6], target = 7",
                    "steps": [
                        {
                            "iteration": 1,
                            "description": "Inicializando variables",
                            "variables": {
                                "input": "nums = [1,3,5,6], target = 7"
                            },
                            "code_line": "Inicio del algoritmo"
                        },
                        {
                            "iteration": 2,
                            "description": "Procesando entrada",
                            "variables": {
                                "input": "nums = [1,3,5,6], target = 7",
                                "processing": true
                            },
                            "code_line": "Iterando sobre los datos"
                        },
                        {
                            "iteration": 3,
                            "description": "Resultado final",
                            "variables": {
                                "input": "nums = [1,3,5,6], target = 7",
                                "result": "4"
                            },
                            "code_line": "return resultado",
                            "output": "4"
                        }
                    ],
                    "final_output": "4"
                }
            }
        ]
    },
    {
        "id": "intersection-of-two-linked-lists",
        "title": "160. Intersection of Two Linked Lists",
        "difficulty": "Easy",
        "description": "Dadas las cabezas de dos listas enlazadas simples, `headA` y `headB`, devuelve el nodo en el que las dos listas se cruzan. Si las dos listas no se cruzan, devuelve `null`.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Two Pointers (Óptima)",
                "explanation": "La solución más ingeniosa y eficiente. Usamos dos punteros, `pA` y `pB`, que comienzan en `headA` y `headB`. Ambos recorren sus listas. Cuando uno llega al final, salta a la cabeza de la *otra* lista. De esta manera, ambos punteros recorren la misma distancia total (`lenA + lenB`). Si hay una intersección, se encontrarán en el nodo de intersección. Si no, se encontrarán en `null` al final.",
                "code_snippet": "function getIntersectionNode(headA, headB) {\n    if (!headA || !headB) return null;\n\n    let pA = headA;\n    let pB = headB;\n\n    while (pA !== pB) {\n        pA = (pA === null) ? headB : pA.next;\n        pB = (pB === null) ? headA : pB.next;\n    }\n    return pA; // O pB, serán el mismo nodo o null\n}",
                "complexity": "Time: O(M + N), Space: O(1)",
                "example": "Input: listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], intersectVal = 8\nOutput: Nodo con valor 8"
            },
            {
                "id": 2,
                "title": "Solución 2: Hash Set",
                "explanation": "Un enfoque intuitivo que utiliza espacio extra. Primero, recorremos una de las listas (por ejemplo, `listA`) y almacenamos cada nodo visitado en un `Set`. Luego, recorremos la segunda lista (`listB`). Para cada nodo de `listB`, comprobamos si ya existe en el `Set`. El primer nodo que encontremos en el `Set` es el punto de intersección.",
                "code_snippet": "function getIntersectionNode(headA, headB) {\n    const visited = new Set();\n\n    let current = headA;\n    while (current) {\n        visited.add(current);\n        current = current.next;\n    }\n\n    current = headB;\n    while (current) {\n        if (visited.has(current)) {\n            return current;\n        }\n        current = current.next;\n    }\n\n    return null;\n}",
                "complexity": "Time: O(M + N), Space: O(M) o O(N)",
                "example": "Input: listA = [1,9,1,2,4], listB = [3,2,4], intersectVal = 2\nOutput: Nodo con valor 2"
            },
            {
                "id": 3,
                "title": "Solución 3: Fuerza Bruta",
                "explanation": "La solución más simple conceptualmente pero la menos eficiente. Por cada nodo en la `listA`, recorremos la `listB` completa desde su cabeza para ver si algún nodo coincide. Si encontramos una coincidencia de referencias de nodo, hemos encontrado la intersección. Este enfoque tiene una complejidad cuadrática.",
                "code_snippet": "function getIntersectionNode(headA, headB) {\n    let pA = headA;\n    while (pA) {\n        let pB = headB;\n        while (pB) {\n            if (pA === pB) {\n                return pA;\n            }\n            pB = pB.next;\n        }\n        pA = pA.next;\n    }\n    return null;\n}",
                "complexity": "Time: O(M * N), Space: O(1)",
                "example": "Input: listA = [2,6,4], listB = [1,5], intersectVal = 0\nOutput: null"
            }
        ]
    },
    {
        "id": "excel-sheet-column-number",
        "title": "171. Excel Sheet Column Number",
        "difficulty": "Easy",
        "description": "Dada una cadena `columnTitle` que representa el título de una columna como aparece en una hoja de Excel, devuelve su número de columna correspondiente. Por ejemplo, `A -> 1`, `B -> 2`, `Z -> 26`, `AA -> 27`, `AB -> 28`.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Iteración de Izquierda a Derecha",
                "explanation": "Este problema es equivalente a convertir un número en base 26 a base 10. Iteramos a través de la cadena de izquierda a derecha. En cada paso, multiplicamos el resultado acumulado por 26 y le sumamos el valor del carácter actual. El valor de un carácter se calcula como `(su código ASCII - código ASCII de 'A' + 1)`.",
                "code_snippet": "function titleToNumber(columnTitle) {\n    let result = 0;\n    const base = 'A'.charCodeAt(0) - 1;\n\n    for (const char of columnTitle) {\n        result = result * 26 + (char.charCodeAt(0) - base);\n    }\n    return result;\n}",
                "complexity": "Time: O(N), donde N es la longitud del título. Space: O(1)",
                "example": "Input: \"AB\"\nOutput: 28"
            },
            {
                "id": 2,
                "title": "Solución 2: Iteración de Derecha a Izquierda",
                "explanation": "Este enfoque imita más de cerca cómo calculamos manualmente los valores en un sistema de bases. Iteramos desde el final de la cadena hacia el principio. Mantenemos una variable `powerOf26` que comienza en 1. En cada paso, calculamos el valor del carácter, lo multiplicamos por `powerOf26` y lo sumamos al resultado. Luego, multiplicamos `powerOf26` por 26 para la siguiente iteración.",
                "code_snippet": "function titleToNumber(columnTitle) {\n    let result = 0;\n    let powerOf26 = 1;\n    const base = 'A'.charCodeAt(0) - 1;\n\n    for (let i = columnTitle.length - 1; i >= 0; i--) {\n        const charVal = columnTitle.charCodeAt(i) - base;\n        result += charVal * powerOf26;\n        powerOf26 *= 26;\n    }\n    return result;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": "Input: \"ZY\"\nOutput: 701"
            },
            {
                "id": 3,
                "title": "Solución 3: Funcional con `reduce`",
                "explanation": "Una forma más concisa y funcional de escribir la lógica de izquierda a derecha en JavaScript. Convertimos la cadena en un array de caracteres y usamos el método `reduce`. El acumulador (`acc`) representa el resultado hasta el momento, que se multiplica por 26 en cada paso antes de sumar el valor del carácter actual.",
                "code_snippet": "function titleToNumber(columnTitle) {\n    const base = 'A'.charCodeAt(0) - 1;\n    return columnTitle.split('').reduce((acc, char) => {\n        return acc * 26 + (char.charCodeAt(0) - base);\n    }, 0);\n}",
                "complexity": "Time: O(N), Space: O(N) [por el array intermedio de split]",
                "example": "Input: \"A\"\nOutput: 1"
            }
        ]
    },
    {
        "id": "pascals-triangle",
        "title": "118. Pascal's Triangle",
        "difficulty": "Easy",
        "description": "Dado un entero `numRows`, genera las primeras `numRows` del Triángulo de Pascal. En el Triángulo de Pascal, cada número es la suma de los dos números directamente encima de él.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Simulación Iterativa",
                "explanation": "Este es el enfoque más directo. Construimos el triángulo fila por fila. Empezamos con la primera fila `[1]`. Luego, en un bucle, generamos cada nueva fila basándonos en la fila anterior. Cada elemento de la nueva fila (excepto los extremos, que siempre son 1) es la suma de los dos elementos correspondientes de la fila anterior.",
                "code_snippet": "function generate(numRows) {\n    if (numRows === 0) return [];\n    const triangle = [[1]];\n\n    for (let i = 1; i < numRows; i++) {\n        const prevRow = triangle[i - 1];\n        const newRow = [1];\n        for (let j = 1; j < prevRow.length; j++) {\n            newRow.push(prevRow[j - 1] + prevRow[j]);\n        }\n        newRow.push(1);\n        triangle.push(newRow);\n    }\n    return triangle;\n}",
                "complexity": "Time: O(numRows^2), Space: O(numRows^2)",
                "example": "Input: numRows = 5\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]"
            },
            {
                "id": 2,
                "title": "Solución 2: Usando la Fórmula Matemática",
                "explanation": "Cada elemento en el Triángulo de Pascal en la fila `n` y columna `k` es `C(n, k)`, el coeficiente binomial. Podemos calcular cada elemento de una fila a partir del anterior. El primer elemento de una fila es `C(n, 0) = 1`. El siguiente es `C(n, 1) = C(n, 0) * (n - 0) / 1`. En general, `C(n, k) = C(n, k-1) * (n - k + 1) / k`. Esto evita recalcular todo desde la fila anterior.",
                "code_snippet": "function generate(numRows) {\n    const triangle = [];\n    for (let i = 0; i < numRows; i++) {\n        const row = [1];\n        let current = 1;\n        for (let j = 1; j <= i; j++) {\n            current = current * (i - j + 1) / j;\n            row.push(current);\n        }\n        triangle.push(row);\n    }\n    return triangle;\n}",
                "complexity": "Time: O(numRows^2), Space: O(numRows^2)",
                "example": "Input: numRows = 3\nOutput: [[1],[1,1],[1,2,1]]"
            },
            {
                "id": 3,
                "title": "Solución 3: Recursiva",
                "explanation": "Podemos definir el problema de forma recursiva. Para generar `n` filas, primero generamos `n-1` filas recursivamente, y luego construimos la `n`-ésima fila a partir de la última fila obtenida en la llamada recursiva. El caso base es cuando `numRows` es 1. Aunque es conceptualmente válido, es menos eficiente que el enfoque iterativo.",
                "code_snippet": "function generate(numRows) {\n    if (numRows === 1) return [[1]];\n    if (numRows === 0) return [];\n\n    const prevTriangle = generate(numRows - 1);\n    const prevRow = prevTriangle[prevTriangle.length - 1];\n    const newRow = [1];\n\n    for (let j = 1; j < prevRow.length; j++) {\n        newRow.push(prevRow[j - 1] + prevRow[j]);\n    }\n    newRow.push(1);\n\n    prevTriangle.push(newRow);\n    return prevTriangle;\n}",
                "complexity": "Time: O(numRows^2), Space: O(numRows^2)",
                "example": "Input: numRows = 1\nOutput: [[1]]"
            }
        ]
    },
    {
        "id": "convert-sorted-array-to-binary-search-tree",
        "title": "108. Convert Sorted Array to Binary Search Tree",
        "difficulty": "Easy",
        "description": "Dado un array de enteros `nums` donde los elementos están ordenados en orden ascendente, conviértelo en un Árbol de Búsqueda Binario (BST) de altura balanceada.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Recursión (Pre-order Traversal)",
                "explanation": "La solución óptima y más natural. Para asegurar que el árbol esté balanceado, el elemento del medio del array debe ser la raíz del árbol. El subarray a la izquierda del medio formará el subárbol izquierdo, y el subarray a la derecha formará el subárbol derecho. Aplicamos esta lógica recursivamente a los subarrays.",
                "code_snippet": "function sortedArrayToBST(nums) {\n    if (!nums.length) return null;\n\n    function build(left, right) {\n        if (left > right) return null;\n\n        const mid = Math.floor(left + (right - left) / 2);\n        const node = new TreeNode(nums[mid]);\n        \n        node.left = build(left, mid - 1);\n        node.right = build(mid + 1, right);\n        \n        return node;\n    }\n\n    return build(0, nums.length - 1);\n}",
                "complexity": "Time: O(N), Space: O(log N) [por la pila de recursión]",
                "example": "Input: nums = [-10,-3,0,5,9]\nOutput: [0,-3,9,-10,null,5]"
            },
            {
                "id": 2,
                "title": "Solución 2: Iterativa con Pila",
                "explanation": "Podemos simular la recursión de forma iterativa usando una pila. La pila almacenará tuplas de `[nodo, límite_izquierdo, límite_derecho]`. Empezamos con la raíz y los límites del array completo. En cada paso, sacamos un elemento, calculamos el medio, asignamos el valor y luego empujamos los subproblemas izquierdo y derecho a la pila para su posterior procesamiento.",
                "code_snippet": "function sortedArrayToBST(nums) {\n    if (!nums.length) return null;\n\n    const root = new TreeNode();\n    const stack = [[root, 0, nums.length - 1]];\n\n    while (stack.length > 0) {\n        const [node, left, right] = stack.pop();\n        const mid = Math.floor(left + (right - left) / 2);\n        node.val = nums[mid];\n\n        if (left <= mid - 1) {\n            node.left = new TreeNode();\n            stack.push([node.left, left, mid - 1]);\n        }\n        if (mid + 1 <= right) {\n            node.right = new TreeNode();\n            stack.push([node.right, mid + 1, right]);\n        }\n    }\n    return root;\n}",
                "complexity": "Time: O(N), Space: O(N) [en el peor caso]",
                "example": "Input: nums = [1,3]\nOutput: [3,1] o [1,null,3]"
            },
            {
                "id": 3,
                "title": "Solución 3: Usando `slice` (Menos Eficiente)",
                "explanation": "Una variación de la solución recursiva que es más fácil de leer pero menos eficiente debido al uso de `slice`. En lugar de pasar índices, creamos nuevos subarrays para las llamadas recursivas. `slice` tiene un costo de O(K) donde K es el tamaño de la rebanada, lo que hace que la complejidad total del tiempo sea mayor.",
                "code_snippet": "function sortedArrayToBST(nums) {\n    if (!nums.length) return null;\n\n    const mid = Math.floor(nums.length / 2);\n    const root = new TreeNode(nums[mid]);\n\n    // slice crea nuevos arrays en cada llamada\n    root.left = sortedArrayToBST(nums.slice(0, mid));\n    root.right = sortedArrayToBST(nums.slice(mid + 1));\n\n    return root;\n}",
                "complexity": "Time: O(N log N) [debido a slice], Space: O(N) [por los nuevos arrays]",
                "example": "Input: nums = [-10,-3,0,5,9]\nOutput: [0,-3,9,-10,null,5]"
            }
        ]
    },
    {
        "id": "search-insert-position",
        "title": "035. Search Insert Position",
        "difficulty": "Easy",
        "description": "Dado un array ordenado de enteros distintos y un valor objetivo, devuelve el índice si se encuentra el objetivo. Si no, devuelve el índice donde estaría si se insertara en orden.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Búsqueda Binaria",
                "explanation": "El enfoque óptimo. Utilizamos búsqueda binaria para encontrar el objetivo. Si lo encontramos, devolvemos su índice. Si el bucle termina sin encontrar el objetivo (`left > right`), el puntero `left` apuntará exactamente a la posición donde el objetivo debería insertarse para mantener el orden. Por lo tanto, simplemente devolvemos `left`.",
                "code_snippet": "function searchInsert(nums, target) {\n    let left = 0;\n    let right = nums.length - 1;\n\n    while (left <= right) {\n        let mid = Math.floor(left + (right - left) / 2);\n        if (nums[mid] === target) {\n            return mid;\n        } else if (nums[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    // Si no se encuentra, 'left' es la posición de inserción.\n    return left;\n}",
                "complexity": "Time: O(log N), Space: O(1)",
                "example": "Input: nums = [1,3,5,6], target = 5\nOutput: 2"
            },
            {
                "id": 2,
                "title": "Solución 2: Búsqueda Lineal",
                "explanation": "La solución de fuerza bruta. Recorremos el array desde el principio. Buscamos el primer elemento que sea igual o mayor que el objetivo. El índice de ese elemento es la respuesta. Si recorremos todo el array y todos los elementos son menores que el objetivo, la posición de inserción es al final del array (`nums.length`).",
                "code_snippet": "function searchInsert(nums, target) {\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] >= target) {\n            return i;\n        }\n    }\n    return nums.length;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": "Input: nums = [1,3,5,6], target = 2\nOutput: 1"
            },
            {
                "id": 3,
                "title": "Solución 3: Usando `findIndex`",
                "explanation": "Un enfoque funcional y conciso en JavaScript. El método `findIndex` devuelve el índice del primer elemento que satisface una condición. Buscamos el primer elemento que sea mayor o igual que el `target`. Si se encuentra, `findIndex` devuelve su índice. Si no se encuentra ningún elemento así (lo que significa que el `target` debe ir al final), `findIndex` devuelve -1. En ese caso, devolvemos la longitud del array.",
                "code_snippet": "function searchInsert(nums, target) {\n    const index = nums.findIndex(num => num >= target);\n    return index === -1 ? nums.length : index;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": "Input: nums = [1,3,5,6], target = 7\nOutput: 4"
            }
        ]
    },
    {
        "id": "find-the-index-of-the-first-occurrence-in-a-string",
        "title": "028. Find the Index of the First Occurrence in a String",
        "difficulty": "Easy",
        "description": "Dada dos cadenas, `haystack` (pajar) y `needle` (aguja), devuelve el índice de la primera ocurrencia de `needle` en `haystack`, o -1 si `needle` no es parte de `haystack`.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Usando Métodos de Lenguaje Integrados",
                "explanation": "La solución más simple y práctica en la mayoría de los lenguajes. Se utiliza una función de biblioteca estándar como `indexOf()` o `find()` que está altamente optimizada para esta tarea. Devuelve directamente el resultado de esta función.",
                "code_snippet": "function strStr(haystack, needle) {\n    return haystack.indexOf(needle);\n}",
                "complexity": "Time: O(N * M) en el peor caso, pero a menudo optimizado a O(N + M) con algoritmos como Boyer-Moore. Space: O(1)",
                "example": "Input: haystack = \"sadbutsad\", needle = \"sad\"\nOutput: 0"
            },
            {
                "id": 2,
                "title": "Solución 2: Fuerza Bruta con Slicing",
                "explanation": "Este es el enfoque de implementación manual más directo. Iteramos a través de `haystack` con un puntero `i`. En cada posición, extraemos una subcadena de la longitud de `needle` y la comparamos con `needle`. Si coinciden, devolvemos `i`.",
                "code_snippet": "function strStr(haystack, needle) {\n    const hLen = haystack.length;\n    const nLen = needle.length;\n    if (nLen === 0) return 0;\n\n    for (let i = 0; i <= hLen - nLen; i++) {\n        if (haystack.substring(i, i + nLen) === needle) {\n            return i;\n        }\n    }\n    return -1;\n}",
                "complexity": "Time: O((N - M) * M), Space: O(M) [por la subcadena]",
                "example": "Input: haystack = \"leetcode\", needle = \"leeto\"\nOutput: -1"
            },
            {
                "id": 3,
                "title": "Solución 3: Fuerza Bruta con Dos Punteros",
                "explanation": "Una versión de la fuerza bruta que evita crear nuevas subcadenas en cada paso, optimizando el espacio. Usamos un bucle externo para `haystack` (`i`) y un bucle interno para `needle` (`j`). Comparamos `haystack[i+j]` con `needle[j]`. Si en algún momento no coinciden, rompemos el bucle interno y continuamos con el siguiente `i`. Si el bucle interno se completa, hemos encontrado una coincidencia.",
                "code_snippet": "function strStr(haystack, needle) {\n    const hLen = haystack.length;\n    const nLen = needle.length;\n    if (nLen === 0) return 0;\n\n    for (let i = 0; i <= hLen - nLen; i++) {\n        let j;\n        for (j = 0; j < nLen; j++) {\n            if (haystack[i + j] !== needle[j]) {\n                break;\n            }\n        }\n        if (j === nLen) {\n            return i; // Coincidencia completa\n        }\n    }\n    return -1;\n}",
                "complexity": "Time: O((N - M) * M), Space: O(1)",
                "example": "Input: haystack = \"hello\", needle = \"ll\"\nOutput: 2"
            }
        ]
    },
    {
        "id": "count-and-say",
        "title": "038. Count-and-Say",
        "difficulty": "Easy",
        "description": "La secuencia `count-and-say` comienza con \"1\" y se genera de la siguiente manera: `countAndSay(n)` es la forma de \"decir\" la cadena de `countAndSay(n-1)`. Para generar el siguiente término, lee en voz alta el término anterior y cuenta el número de dígitos en grupos de dígitos idénticos. Por ejemplo, `countAndSay(4)` es \"1211\", que se lee como \"un 1, un 2, dos 1s\".",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Iterativa",
                "explanation": "La solución más directa. Comenzamos con la cadena `\"1\"`. Luego, iteramos `n-1` veces. En cada iteración, construimos la siguiente cadena leyendo la cadena actual. Usamos un puntero o un bucle para recorrer la cadena actual, contando grupos de caracteres idénticos y añadiendo el conteo y el carácter a una nueva cadena.",
                "code_snippet": "function countAndSay(n) {\n    if (n === 1) return \"1\";\n\n    let result = \"1\";\n\n    for (let i = 2; i <= n; i++) {\n        let nextResult = \"\";\n        let count = 1;\n        for (let j = 0; j < result.length; j++) {\n            if (j + 1 < result.length && result[j] === result[j + 1]) {\n                count++;\n            } else {\n                nextResult += count + result[j];\n                count = 1;\n            }\n        }\n        result = nextResult;\n    }\n    return result;\n}",
                "complexity": "Time: O(N * L), donde L es la longitud promedio de las cadenas. Space: O(L_max)",
                "example": "Input: n = 4\nOutput: \"1211\""
            },
            {
                "id": 2,
                "title": "Solución 2: Recursiva",
                "explanation": "Podemos definir el problema de forma recursiva. `countAndSay(n)` se basa en el resultado de `countAndSay(n-1)`. El caso base es `n=1`, que devuelve \"1\". Para `n > 1`, llamamos recursivamente a la función para `n-1` para obtener la cadena anterior y luego la procesamos para generar la nueva, de la misma manera que en el enfoque iterativo.",
                "code_snippet": "function countAndSay(n) {\n    if (n === 1) return \"1\";\n\n    const prev = countAndSay(n - 1);\n    let result = \"\";\n    let count = 1;\n\n    for (let i = 0; i < prev.length; i++) {\n        if (i + 1 < prev.length && prev[i] === prev[i + 1]) {\n            count++;\n        } else {\n            result += count + prev[i];\n            count = 1;\n        }\n    }\n    return result;\n}",
                "complexity": "Time: O(N * L), Space: O(N * L) [por la pila de recursión]",
                "example": "Input: n = 1\nOutput: \"1\""
            },
            {
                "id": 3,
                "title": "Solución 3: Usando Expresiones Regulares",
                "explanation": "Un enfoque más avanzado y conciso que utiliza expresiones regulares para agrupar caracteres idénticos. Podemos usar una expresión regular como `/(.)\\1*/g` que encuentra un carácter `(.)` seguido por cero o más ocurrencias de ese mismo carácter `\\1*`. Luego, reemplazamos cada coincidencia con una función que devuelve la longitud de la coincidencia y el carácter.",
                "code_snippet": "function countAndSay(n) {\n    let result = '1';\n    for (let i = 1; i < n; i++) {\n        result = result.replace(/(.)\\1*/g, (match, char) => {\n            return match.length + char;\n        });\n    }\n    return result;\n}",
                "complexity": "Time: Depende de la implementación del motor de regex, pero similar a O(N * L). Space: O(L_max)",
                "example": "Input: n = 5\nOutput: \"111221\""
            }
        ]
    },
    {
        "id": "add-binary",
        "title": "067. Add Binary",
        "difficulty": "Easy",
        "description": "Dadas dos cadenas binarias `a` y `b`, devuelve su suma como una cadena binaria.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Simulación Manual con Acarreo (Carry)",
                "explanation": "Este enfoque simula la suma binaria que haríamos a mano. Iteramos desde el final de ambas cadenas, manteniendo una variable `carry` (acarreo). En cada paso, sumamos los bits correspondientes de `a` y `b` más el `carry`. El nuevo bit para el resultado es `suma % 2`, y el nuevo `carry` es `Math.floor(suma / 2)`. Añadimos el nuevo bit al principio del resultado. Continuamos hasta que ambas cadenas y el `carry` se agoten.",
                "code_snippet": "function addBinary(a, b) {\n    let result = \"\";\n    let carry = 0;\n    let i = a.length - 1;\n    let j = b.length - 1;\n\n    while (i >= 0 || j >= 0 || carry > 0) {\n        const valA = i >= 0 ? parseInt(a[i]) : 0;\n        const valB = j >= 0 ? parseInt(b[j]) : 0;\n        \n        const sum = valA + valB + carry;\n        result = (sum % 2) + result;\n        carry = Math.floor(sum / 2);\n        \n        i--;\n        j--;\n    }\n    return result;\n}",
                "complexity": "Time: O(max(N, M)), Space: O(max(N, M))",
                "example": "Input: a = \"11\", b = \"1\"\nOutput: \"100\""
            },
            {
                "id": 2,
                "title": "Solución 2: Usando BigInt",
                "explanation": "Un atajo que aprovecha las capacidades de `BigInt` en JavaScript para manejar enteros grandes. Convertimos las cadenas binarias a `BigInt` anteponiendo `0b`. Luego, sumamos estos dos `BigInt`. Finalmente, convertimos el resultado de nuevo a una cadena binaria usando `.toString(2)`.",
                "code_snippet": "function addBinary(a, b) {\n    const numA = BigInt(`0b${a}`);\n    const numB = BigInt(`0b${b}`);\n    const sum = numA + numB;\n    return sum.toString(2);\n}",
                "complexity": "Time: O(max(N, M)), Space: O(max(N, M))",
                "example": "Input: a = \"1010\", b = \"1011\"\nOutput: \"10101\""
            },
            {
                "id": 3,
                "title": "Solución 3: Rellenar y Sumar con Acarreo",
                "explanation": "Una variación de la simulación manual. Primero, hacemos que ambas cadenas tengan la misma longitud rellenando la más corta con ceros a la izquierda. Luego, iteramos desde el final, realizando la suma con acarreo de la misma manera que en la solución 1. Esto puede simplificar ligeramente la lógica del bucle al no tener que comprobar `i >= 0` y `j >= 0` por separado.",
                "code_snippet": "function addBinary(a, b) {\n    let result = \"\";\n    let carry = 0;\n    const maxLength = Math.max(a.length, b.length);\n    a = a.padStart(maxLength, '0');\n    b = b.padStart(maxLength, '0');\n\n    for (let i = maxLength - 1; i >= 0; i--) {\n        const sum = parseInt(a[i]) + parseInt(b[i]) + carry;\n        result = (sum % 2) + result;\n        carry = Math.floor(sum / 2);\n    }\n\n    if (carry) {\n        result = '1' + result;\n    }\n    return result;\n}",
                "complexity": "Time: O(max(N, M)), Space: O(max(N, M))",
                "example": "Input: a = \"1\", b = \"111\"\nOutput: \"1000\""
            }
        ]
    },
    {
        "id": "pascals-triangle-ii",
        "title": "119. Pascal's Triangle II",
        "difficulty": "Easy",
        "description": "Dado un entero `rowIndex`, devuelve la `rowIndex`-ésima (indexada desde 0) fila del Triángulo de Pascal. Optimiza tu algoritmo para usar solo O(rowIndex) de espacio extra.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Iteración con Espacio Optimizado",
                "explanation": "Podemos generar la fila deseada sin almacenar todo el triángulo. Empezamos con la fila `[1]`. Luego, iteramos `rowIndex` veces. En cada iteración, construimos la siguiente fila a partir de la fila actual. Para cumplir con la restricción de espacio O(k), podemos usar un solo array y actualizarlo. La clave es calcular los nuevos valores de derecha a izquierda para no sobrescribir los valores antiguos que aún necesitamos.",
                "code_snippet": "function getRow(rowIndex) {\n    let row = [1];\n\n    for (let i = 1; i <= rowIndex; i++) {\n        // Calcular la siguiente fila de derecha a izquierda para modificar in-place\n        for (let j = i; j > 0; j--) {\n            if (j === i) {\n                row[j] = 1;\n            } else {\n                row[j] = row[j - 1] + row[j];\n            }\n        }\n    }\n    return row;\n}",
                "complexity": "Time: O(k^2), Space: O(k)",
                "example": "Input: rowIndex = 3\nOutput: [1,3,3,1]"
            },
            {
                "id": 2,
                "title": "Solución 2: Fórmula Matemática (Coeficiente Binomial)",
                "explanation": "Esta es la solución más eficiente en tiempo. Sabemos que cada elemento de la fila `k` es un coeficiente binomial `C(k, i)`. También sabemos que `C(k, i) = C(k, i-1) * (k - i + 1) / i`. Podemos construir la fila calculando cada elemento a partir del anterior en tiempo O(1). Empezamos con `C(k, 0) = 1` y aplicamos la fórmula.",
                "code_snippet": "function getRow(rowIndex) {\n    const row = new Array(rowIndex + 1).fill(0);\n    row[0] = 1;\n\n    for (let i = 1; i <= rowIndex; i++) {\n        // C(k, i) = C(k, i-1) * (k - i + 1) / i\n        row[i] = row[i - 1] * (rowIndex - i + 1) / i;\n    }\n    return row;\n}",
                "complexity": "Time: O(k), Space: O(k)",
                "example": "Input: rowIndex = 0\nOutput: [1]"
            },
            {
                "id": 3,
                "title": "Solución 3: Usando un Array Temporal",
                "explanation": "Un enfoque iterativo ligeramente más simple de entender que la modificación in-place. Mantenemos un array para la fila actual. En cada iteración para construir la siguiente fila, creamos un nuevo array temporal. Llenamos este array temporal basándonos en los valores de la fila actual. Al final de la iteración, reemplazamos la fila actual con el array temporal.",
                "code_snippet": "function getRow(rowIndex) {\n    let row = [1];\n    for (let i = 0; i < rowIndex; i++) {\n        const nextRow = [1];\n        for (let j = 1; j < row.length; j++) {\n            nextRow.push(row[j - 1] + row[j]);\n        }\n        nextRow.push(1);\n        row = nextRow;\n    }\n    return row;\n}",
                "complexity": "Time: O(k^2), Space: O(k)",
                "example": "Input: rowIndex = 1\nOutput: [1,1]"
            }
        ]
    },
    {
        "id": "summary-ranges",
        "title": "228. Summary Ranges",
        "difficulty": "Easy",
        "description": "Se te da un array ordenado y único de enteros `nums`. Devuelve el resumen más pequeño de sus rangos que cubra exactamente todos los números del array. Cada elemento de `nums` debe ser cubierto por exactamente uno de los rangos.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Iteración con Puntero de Inicio",
                "explanation": "El enfoque más común. Recorremos el array con un puntero `i`. Para cada `i`, lo tratamos como el inicio de un posible rango. Luego, usamos un bucle anidado o un segundo puntero para avanzar mientras los números sean consecutivos (`nums[j+1] === nums[j] + 1`). Cuando la secuencia se rompe, hemos encontrado el final del rango. Formateamos y añadimos el rango al resultado y continuamos la búsqueda desde el final de este rango.",
                "code_snippet": "function summaryRanges(nums) {\n    const result = [];\n    if (nums.length === 0) return result;\n\n    for (let i = 0; i < nums.length; i++) {\n        let start = nums[i];\n        // Avanzar mientras los números sean consecutivos\n        while (i + 1 < nums.length && nums[i + 1] === nums[i] + 1) {\n            i++;\n        }\n\n        if (start === nums[i]) {\n            result.push(`${start}`);\n        } else {\n            result.push(`${start}->${nums[i]}`);\n        }\n    }\n    return result;\n}",
                "complexity": "Time: O(N), Space: O(1) [sin contar la salida]",
                "example": "Input: nums = [0,1,2,4,5,7]\nOutput: [\"0->2\",\"4->5\",\"7\"]"
            },
            {
                "id": 2,
                "title": "Solución 2: Un Solo Bucle con Ancla",
                "explanation": "Una variación del primer enfoque que usa una sola variable `anchor` para marcar el inicio de un rango. Iteramos con un puntero `i`. Comprobamos si el elemento actual `nums[i]` no es consecutivo con el anterior. Si no lo es (o si estamos al principio), significa que un rango ha terminado. Formateamos el rango desde `anchor` hasta `nums[i-1]` y actualizamos `anchor` a la posición actual `i`. Se maneja un caso especial al final para el último rango.",
                "code_snippet": "function summaryRanges(nums) {\n    const result = [];\n    if (nums.length === 0) return result;\n\n    let anchor = nums[0];\n\n    for (let i = 1; i <= nums.length; i++) {\n        // El rango se rompe o llegamos al final\n        if (i === nums.length || nums[i] !== nums[i - 1] + 1) {\n            if (anchor === nums[i - 1]) {\n                result.push(`${anchor}`);\n            } else {\n                result.push(`${anchor}->${nums[i - 1]}`);\n            }\n            if (i < nums.length) {\n                anchor = nums[i];\n            }\n        }\n    }\n    return result;\n}",
                "complexity": "Time: O(N), Space: O(1) [sin contar la salida]",
                "example": "Input: nums = [0,2,3,4,6,8,9]\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]"
            },
            {
                "id": 3,
                "title": "Solución 3: Funcional con `reduce`",
                "explanation": "Un enfoque funcional que puede ser más conciso pero potencialmente menos legible. Usamos `reduce` para procesar el array. El acumulador mantiene el estado, que incluye la lista de rangos y el rango actual que se está construyendo. En cada paso, decidimos si el número actual extiende el rango actual o si inicia uno nuevo.",
                "code_snippet": "function summaryRanges(nums) {\n    if (nums.length === 0) return [];\n    return nums.reduce((ranges, num) => {\n        if (ranges.length === 0) {\n            ranges.push([num, num]);\n        } else {\n            let lastRange = ranges[ranges.length - 1];\n            if (num === lastRange[1] + 1) {\n                lastRange[1] = num;\n            } else {\n                ranges.push([num, num]);\n            }\n        }\n        return ranges;\n    }, []).map(range => (range[0] === range[1] ? `${range[0]}` : `${range[0]}->${range[1]}`));\n}",
                "complexity": "Time: O(N), Space: O(N) [por el array de salida]",
                "example": "Input: nums = []\nOutput: []"
            }
        ]
    },
    {
        "id": "remove-linked-list-elements",
        "title": "203. Remove Linked List Elements",
        "difficulty": "Easy",
        "description": "Dada la `head` de una lista enlazada y un entero `val`, elimina todos los nodos de la lista que tengan `Node.val == val`, y devuelve la nueva cabeza.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Iterativa con Nodo Dummy",
                "explanation": "La solución más robusta y recomendada. Se crea un 'nodo dummy' que apunta a la cabeza original. Esto simplifica el manejo de casos especiales, como eliminar el nodo cabeza. Usamos un puntero `prev` que comienza en el dummy. Recorremos la lista y, si `prev.next.val` es igual a `val`, saltamos ese nodo haciendo `prev.next = prev.next.next`. Si no, simplemente avanzamos `prev`.",
                "code_snippet": "function removeElements(head, val) {\n    const dummy = new ListNode(0, head);\n    let prev = dummy;\n    let current = head;\n\n    while (current) {\n        if (current.val === val) {\n            prev.next = current.next;\n        } else {\n            prev = current;\n        }\n        current = current.next;\n    }\n    return dummy.next;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": "Input: head = [1,2,6,3,4,5,6], val = 6\nOutput: [1,2,3,4,5]"
            },
            {
                "id": 2,
                "title": "Solución 2: Iterativa sin Nodo Dummy",
                "explanation": "Este enfoque evita el nodo dummy pero requiere un manejo especial para la cabeza. Primero, usamos un bucle `while` para avanzar la cabeza de la lista mientras los nodos iniciales tengan el valor a eliminar. Después de eso, el resto de la lógica es similar a la solución 1, usando dos punteros para eliminar los nodos del medio o del final.",
                "code_snippet": "function removeElements(head, val) {\n    // Manejar el caso de que la cabeza(s) tenga el valor\n    while (head && head.val === val) {\n        head = head.next;\n    }\n    if (!head) return null;\n\n    let current = head;\n    while (current.next) {\n        if (current.next.val === val) {\n            current.next = current.next.next;\n        } else {\n            current = current.next;\n        }\n    }\n    return head;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": "Input: head = [7,7,7,7], val = 7\nOutput: []"
            },
            {
                "id": 3,
                "title": "Solución 3: Recursiva",
                "explanation": "Un enfoque elegante que define el problema en términos de sí mismo. La función devuelve la cabeza de la lista procesada. Primero, llama recursivamente a `removeElements` en el resto de la lista (`head.next`). Esto nos da una sublista ya limpia. Luego, decidimos qué hacer con el nodo `head` actual: si su valor es `val`, lo descartamos y devolvemos la sublista limpia. Si no, lo mantenemos y apuntamos su `next` a la sublista limpia.",
                "code_snippet": "function removeElements(head, val) {\n    if (!head) return null;\n\n    // Primero, procesa el resto de la lista\n    head.next = removeElements(head.next, val);\n\n    // Luego, decide sobre el nodo actual\n    if (head.val === val) {\n        return head.next; // Descarta el nodo actual\n    } else {\n        return head; // Mantiene el nodo actual\n    }\n}",
                "complexity": "Time: O(N), Space: O(N) [por la pila de recursión]",
                "example": "Input: head = [1,2,2,1], val = 2\nOutput: [1,1]"
            }
        ]
    },
    {
        "id": "valid-palindrome",
        "title": "125. Valid Palindrome",
        "difficulty": "Easy",
        "description": "Una frase es un palíndromo si, después de convertir todas las letras mayúsculas en minúsculas y eliminar todos los caracteres no alfanuméricos, se lee igual hacia adelante y hacia atrás. Dado una cadena `s`, devuelve `true` si es un palíndromo, o `false` en caso contrario.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Two Pointers (Óptima)",
                "explanation": "La solución más eficiente. Usamos dos punteros, `left` al inicio y `right` al final. En un bucle, avanzamos `left` y retrocedemos `right` para saltar cualquier carácter no alfanumérico. Luego, comparamos los caracteres en las posiciones `left` y `right` (convertidos a minúsculas). Si en algún momento no coinciden, devolvemos `false`. Si el bucle termina, es un palíndromo.",
                "code_snippet": "function isPalindrome(s) {\n    let left = 0, right = s.length - 1;\n    const isAlphanumeric = (char) => /[a-zA-Z0-9]/.test(char);\n\n    while (left < right) {\n        while (left < right && !isAlphanumeric(s[left])) left++;\n        while (left < right && !isAlphanumeric(s[right])) right--;\n\n        if (s[left].toLowerCase() !== s[right].toLowerCase()) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": "Input: s = \"A man, a plan, a canal: Panama\"\nOutput: true"
            },
            {
                "id": 2,
                "title": "Solución 2: Filtrar y Revertir",
                "explanation": "Un enfoque más simple pero que usa más espacio. Primero, creamos una nueva cadena 'limpia' iterando sobre la original y añadiendo solo los caracteres alfanuméricos, convertidos a minúsculas. Luego, comparamos esta cadena limpia con su versión invertida. Si son iguales, es un palíndromo.",
                "code_snippet": "function isPalindrome(s) {\n    // Filtrar caracteres no alfanuméricos y convertir a minúsculas\n    const sanitized = s.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();\n    \n    // Revertir la cadena y comparar\n    const reversed = sanitized.split('').reverse().join('');\n    \n    return sanitized === reversed;\n}",
                "complexity": "Time: O(N), Space: O(N)",
                "example": "Input: s = \"race a car\"\nOutput: false"
            },
            {
                "id": 3,
                "title": "Solución 3: Filtrar y Two Pointers",
                "explanation": "Una mezcla de los dos enfoques anteriores. Primero, creamos la cadena 'limpia' como en la solución 2. Luego, aplicamos la lógica de los dos punteros a esta cadena limpia. Esto separa la lógica de limpieza de la lógica de verificación, lo que puede hacer el código un poco más claro, a costa de espacio adicional.",
                "code_snippet": "function isPalindrome(s) {\n    const sanitized = s.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();\n    let left = 0, right = sanitized.length - 1;\n\n    while (left < right) {\n        if (sanitized[left] !== sanitized[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}",
                "complexity": "Time: O(N), Space: O(N)",
                "example": "Input: s = \" \"\nOutput: true"
            }
        ]
    },
    {
        "id": "is-subsequence",
        "title": "392. Is Subsequence",
        "difficulty": "Easy",
        "description": "Dadas dos cadenas `s` y `t`, devuelve `true` si `s` es una subsecuencia de `t`, o `false` en caso contrario. Una subsecuencia es una nueva cadena formada a partir de la original eliminando algunos (o ninguno) de los caracteres sin perturbar el orden relativo de los caracteres restantes.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Two Pointers",
                "explanation": "El enfoque más eficiente e intuitivo. Usamos un puntero para `s` (`s_ptr`) y otro para `t` (`t_ptr`). Recorremos `t`. Si el carácter en `t_ptr` coincide con el carácter en `s_ptr`, significa que hemos encontrado el siguiente carácter de la subsecuencia, por lo que avanzamos `s_ptr`. Siempre avanzamos `t_ptr`. Si `s_ptr` llega al final de `s`, hemos encontrado todos sus caracteres en orden.",
                "code_snippet": "function isSubsequence(s, t) {\n    let s_ptr = 0;\n    let t_ptr = 0;\n\n    while (s_ptr < s.length && t_ptr < t.length) {\n        if (s[s_ptr] === t[t_ptr]) {\n            s_ptr++;\n        }\n        t_ptr++;\n    }\n    return s_ptr === s.length;\n}",
                "complexity": "Time: O(longitud de T), Space: O(1)",
                "example": "Input: s = \"abc\", t = \"ahbgdc\"\nOutput: true"
            },
            {
                "id": 2,
                "title": "Solución 2: Usando `indexOf`",
                "explanation": "Un enfoque iterativo que utiliza un método de cadena incorporado. Mantenemos un índice (`fromIndex`) que rastrea dónde buscar en `t`. Por cada carácter en `s`, usamos `t.indexOf(char, fromIndex)` para encontrar su próxima ocurrencia. Si `indexOf` devuelve -1, el carácter no se encontró, por lo que no es una subsecuencia. Si se encuentra, actualizamos `fromIndex` para comenzar la siguiente búsqueda desde esa posición.",
                "code_snippet": "function isSubsequence(s, t) {\n    let fromIndex = 0;\n    for (const char of s) {\n        const foundIndex = t.indexOf(char, fromIndex);\n        if (foundIndex === -1) {\n            return false;\n        }\n        fromIndex = foundIndex + 1;\n    }\n    return true;\n}",
                "complexity": "Time: O(longitud de S * longitud de T) en el peor caso. Space: O(1)",
                "example": "Input: s = \"axc\", t = \"ahbgdc\"\nOutput: false"
            },
            {
                "id": 3,
                "title": "Solución 3: Recursiva",
                "explanation": "Definimos una función auxiliar que toma los índices actuales de `s` y `t`. El caso base es si hemos encontrado toda la cadena `s`. En el paso recursivo, buscamos el carácter actual de `s` (`s[s_idx]`) en el resto de `t` (desde `t_idx`). Si lo encontramos en `t_new_idx`, hacemos una llamada recursiva para el siguiente carácter de `s` desde `t_new_idx + 1`. Este enfoque es conceptualmente claro pero menos eficiente que los punteros.",
                "code_snippet": "function isSubsequence(s, t) {\n    function check(s_idx, t_idx) {\n        if (s_idx === s.length) return true;\n        if (t_idx === t.length) return false;\n\n        if (s[s_idx] === t[t_idx]) {\n            return check(s_idx + 1, t_idx + 1);\n        } else {\n            return check(s_idx, t_idx + 1);\n        }\n    }\n    return check(0, 0);\n}",
                "complexity": "Time: O(longitud de T), Space: O(longitud de T) [por la pila de recursión]",
                "example": "Input: s = \"ace\", t = \"abcde\"\nOutput: true"
            }
        ]
    },
    {
        "id": "fibonacci-number",
        "title": "509. Fibonacci Number",
        "difficulty": "Easy",
        "description": "El número de Fibonacci, comúnmente denotado `F(n)`, forma una secuencia donde cada número es la suma de los dos anteriores, comenzando desde 0 y 1. Es decir, `F(0) = 0`, `F(1) = 1`, `F(n) = F(n-1) + F(n-2)` para `n > 1`. Dado `n`, calcula `F(n)`.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Iterativa (Bottom-Up DP)",
                "explanation": "La solución más eficiente en espacio y tiempo para este problema. Mantenemos dos variables para almacenar los dos números de Fibonacci anteriores (`a` y `b`). En un bucle de 2 a `n`, calculamos el siguiente número sumando `a` y `b`, y luego actualizamos `a` y `b` para la siguiente iteración. Esto evita la recursión y usa espacio constante.",
                "code_snippet": "function fib(n) {\n    if (n <= 1) return n;\n    let a = 0, b = 1;\n    for (let i = 2; i <= n; i++) {\n        const temp = a + b;\n        a = b;\n        b = temp;\n    }\n    return b;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": "Input: n = 4\nOutput: 3"
            },
            {
                "id": 2,
                "title": "Solución 2: Recursiva con Memoización (Top-Down DP)",
                "explanation": "La implementación recursiva directa `fib(n-1) + fib(n-2)` es muy ineficiente (O(2^n)) debido a cálculos repetidos. La memoización resuelve esto almacenando los resultados de los subproblemas en un caché (como un mapa o un array). Antes de calcular `fib(k)`, verificamos si ya está en el caché. Si es así, lo devolvemos; de lo contrario, lo calculamos, lo guardamos y lo devolvemos.",
                "code_snippet": "const memo = {};\nfunction fib(n) {\n    if (n <= 1) return n;\n    if (memo[n]) return memo[n];\n\n    memo[n] = fib(n - 1) + fib(n - 2);\n    return memo[n];\n}",
                "complexity": "Time: O(N), Space: O(N)",
                "example": "Input: n = 3\nOutput: 2"
            },
            {
                "id": 3,
                "title": "Solución 3: Fórmula de Binet (Matemática)",
                "explanation": "Un enfoque matemático que utiliza la fórmula de forma cerrada para la secuencia de Fibonacci, basada en la proporción áurea (phi). `F(n) = (phi^n - (1-phi)^n) / sqrt(5)`. Esto calcula el resultado directamente, pero implica aritmética de punto flotante, lo que puede introducir pequeños errores de precisión para números grandes. Es principalmente de interés teórico.",
                "code_snippet": "function fib(n) {\n    const sqrt5 = Math.sqrt(5);\n    const phi = (1 + sqrt5) / 2;\n    \n    return Math.round(Math.pow(phi, n) / sqrt5);\n}",
                "complexity": "Time: O(log N) [debido a Math.pow], Space: O(1)",
                "example": "Input: n = 10\nOutput: 55"
            }
        ]
    },
    {
        "id": "binary-tree-paths",
        "title": "257. Binary Tree Paths",
        "difficulty": "Easy",
        "description": "Dado el `root` de un árbol binario, devuelve todas las rutas de la raíz a la hoja en cualquier orden. Una hoja es un nodo sin hijos.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Recursiva (DFS con Backtracking)",
                "explanation": "El enfoque más natural para este problema. Usamos una función auxiliar de búsqueda en profundidad (DFS). Esta función lleva el nodo actual y la ruta construida hasta ahora. Cuando llegamos a un nodo hoja, añadimos la ruta completa a nuestra lista de resultados. Para los nodos no hoja, llamamos recursivamente a los hijos, añadiendo el valor del nodo actual a la ruta.",
                "code_snippet": "function binaryTreePaths(root) {\n    const paths = [];\n\n    function dfs(node, currentPath) {\n        if (!node) return;\n\n        // Añadir el nodo actual a la ruta\n        currentPath += node.val;\n\n        // Si es una hoja, añadir la ruta completa a los resultados\n        if (!node.left && !node.right) {\n            paths.push(currentPath);\n            return;\n        }\n\n        // Continuar la búsqueda en los hijos\n        currentPath += '->';\n        dfs(node.left, currentPath);\n        dfs(node.right, currentPath);\n    }\n\n    dfs(root, \"\");\n    return paths;\n}",
                "complexity": "Time: O(N), Space: O(H) [Altura del árbol]",
                "example": "Input: root = [1,2,3,null,5]\nOutput: [\"1->2->5\", \"1->3\"]"
            },
            {
                "id": 2,
                "title": "Solución 2: Iterativa con Pila (DFS)",
                "explanation": "Podemos replicar la lógica DFS de forma iterativa usando una pila. La pila almacenará pares de `[nodo, ruta_actual]`. Empezamos empujando la raíz y su valor como cadena. En cada iteración, sacamos un par. Si el nodo es una hoja, añadimos su ruta al resultado. De lo contrario, empujamos a sus hijos a la pila con la cadena de ruta actualizada.",
                "code_snippet": "function binaryTreePaths(root) {\n    if (!root) return [];\n    const paths = [];\n    const stack = [[root, `${root.val}`]];\n\n    while (stack.length > 0) {\n        const [node, path] = stack.pop();\n\n        if (!node.left && !node.right) {\n            paths.push(path);\n        }\n\n        if (node.right) {\n            stack.push([node.right, `${path}->${node.right.val}`]);\n        }\n        if (node.left) {\n            stack.push([node.left, `${path}->${node.left.val}`]);\n        }\n    }\n    return paths;\n}",
                "complexity": "Time: O(N), Space: O(H)",
                "example": "Input: root = [1]\nOutput: [\"1\"]"
            },
            {
                "id": 3,
                "title": "Solución 3: Iterativa con Cola (BFS)",
                "explanation": "Aunque DFS es más natural, también se puede usar BFS. La lógica es idéntica a la solución de pila, pero usando una cola. Esto explorará el árbol nivel por nivel, encontrando primero las rutas más cortas. La cola almacena pares `[nodo, ruta_actual]`. El proceso de comprobación de hojas y añadido de hijos es el mismo.",
                "code_snippet": "function binaryTreePaths(root) {\n    if (!root) return [];\n    const paths = [];\n    const queue = [[root, `${root.val}`]];\n\n    while (queue.length > 0) {\n        const [node, path] = queue.shift();\n\n        if (!node.left && !node.right) {\n            paths.push(path);\n        }\n\n        if (node.left) {\n            queue.push([node.left, `${path}->${node.left.val}`]);\n        }\n        if (node.right) {\n            queue.push([node.right, `${path}->${node.right.val}`]);\n        }\n    }\n    return paths;\n}",
                "complexity": "Time: O(N), Space: O(W) [Ancho máximo del árbol]",
                "example": "Input: root = [3,9,20,null,null,15,7]\nOutput: [\"3->9\", \"3->20->15\", \"3->20->7\"]"
            }
        ]
    },
    {
        "id": "merge-sorted-array",
        "title": "088. Merge Sorted Array",
        "difficulty": "Easy",
        "description": "Se te dan dos arrays de enteros, `nums1` y `nums2`, ordenados en orden no decreciente, y dos enteros `m` y `n` que representan el número de elementos en `nums1` y `nums2` respectivamente. Fusiona `nums2` en `nums1` como un solo array ordenado. El array final debe ser almacenado dentro de `nums1`. `nums1` tiene una longitud de `m + n`, donde los primeros `m` elementos son los que deben ser fusionados y los últimos `n` son 0 y deben ser ignorados.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Two Pointers desde el Final (Óptima)",
                "explanation": "La solución más eficiente que trabaja *in-place*. Dado que los últimos `n` elementos de `nums1` están vacíos, podemos llenarlos desde el final sin sobrescribir los elementos que necesitamos comparar. Usamos tres punteros: uno para el final de los elementos de `nums1` (`p1`), uno para el final de `nums2` (`p2`), y uno para el final del array `nums1` completo (`p`). Comparamos los elementos en `p1` y `p2` y colocamos el mayor en la posición `p`.",
                "code_snippet": "function merge(nums1, m, nums2, n) {\n    let p1 = m - 1;\n    let p2 = n - 1;\n    let p = m + n - 1;\n\n    while (p2 >= 0) {\n        if (p1 >= 0 && nums1[p1] > nums2[p2]) {\n            nums1[p] = nums1[p1];\n            p1--;\n        } else {\n            nums1[p] = nums2[p2];\n            p2--;\n        }\n        p--;\n    }\n}",
                "complexity": "Time: O(m + n), Space: O(1)",
                "example": "Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\nOutput: [1,2,2,3,5,6]"
            },
            {
                "id": 2,
                "title": "Solución 2: Hacer una Copia y Fusionar",
                "explanation": "Un enfoque más simple de entender pero que usa espacio extra. Primero, hacemos una copia de los primeros `m` elementos de `nums1`. Luego, usamos la técnica estándar de fusión de dos arrays ordenados con dos punteros (`p1_copy` y `p2`) para llenar el `nums1` original desde el principio.",
                "code_snippet": "function merge(nums1, m, nums2, n) {\n    const nums1_copy = nums1.slice(0, m);\n    let p1 = 0;\n    let p2 = 0;\n    let p = 0;\n\n    while (p1 < m && p2 < n) {\n        if (nums1_copy[p1] <= nums2[p2]) {\n            nums1[p++] = nums1_copy[p1++];\n        } else {\n            nums1[p++] = nums2[p2++];\n        }\n    }\n    while (p1 < m) nums1[p++] = nums1_copy[p1++];\n    while (p2 < n) nums1[p++] = nums2[p2++];\n}",
                "complexity": "Time: O(m + n), Space: O(m)",
                "example": "Input: nums1 = [1], m = 1, nums2 = [], n = 0\nOutput: [1]"
            },
            {
                "id": 3,
                "title": "Solución 3: Insertar y Ordenar (Naive)",
                "explanation": "La solución más sencilla de escribir, pero la menos eficiente en tiempo. Simplemente copiamos todos los elementos de `nums2` en los espacios vacíos al final de `nums1`. Luego, llamamos a la función de ordenación del lenguaje sobre todo el array `nums1`.",
                "code_snippet": "function merge(nums1, m, nums2, n) {\n    for (let i = 0; i < n; i++) {\n        nums1[m + i] = nums2[i];\n    }\n    nums1.sort((a, b) => a - b);\n}",
                "complexity": "Time: O((m+n) log(m+n)), Space: O(1) o O(log(m+n)) [dependiendo del sort]",
                "example": "Input: nums1 = [0], m = 0, nums2 = [1], n = 1\nOutput: [1]"
            }
        ]
    },
    {
        "id": "middle-of-the-linked-list",
        "title": "876. Middle of the Linked List",
        "difficulty": "Easy",
        "description": "Dada la cabeza de una lista enlazada simple, devuelve el nodo del medio de la lista. Si hay dos nodos en el medio, devuelve el segundo nodo del medio.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Two Pointers (Lento y Rápido)",
                "explanation": "El algoritmo de la Tortuga y la Liebre. Usamos dos punteros, `slow` y `fast`, ambos comenzando en la cabeza. `slow` avanza un nodo a la vez, mientras que `fast` avanza dos. Cuando el puntero `fast` llega al final de la lista (o a su último nodo), el puntero `slow` estará exactamente en el medio. Este es el método más eficiente.",
                "code_snippet": "function middleNode(head) {\n    let slow = head;\n    let fast = head;\n    while (fast && fast.next) {\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return slow;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": "Input: [1,2,3,4,5]\nOutput: Nodo con valor 3"
            },
            {
                "id": 2,
                "title": "Solución 2: Almacenar en un Array",
                "explanation": "Un enfoque directo que usa más espacio. Recorremos toda la lista enlazada una vez, almacenando cada nodo en un array. Una vez que hemos recorrido toda la lista, el nodo del medio se puede encontrar fácilmente calculando el índice medio del array (`Math.floor(array.length / 2)`).",
                "code_snippet": "function middleNode(head) {\n    const arr = [];\n    let current = head;\n    while (current) {\n        arr.push(current);\n        current = current.next;\n    }\n    return arr[Math.floor(arr.length / 2)];\n}",
                "complexity": "Time: O(N), Space: O(N)",
                "example": "Input: [1,2,3,4,5,6]\nOutput: Nodo con valor 4"
            },
            {
                "id": 3,
                "title": "Solución 3: Dos Pasadas",
                "explanation": "Este enfoque evita el uso de espacio extra a costa de recorrer la lista dos veces. En la primera pasada, contamos el número total de nodos, `N`. En la segunda pasada, iteramos desde la cabeza `N / 2` veces para llegar al nodo del medio.",
                "code_snippet": "function middleNode(head) {\n    let count = 0;\n    let current = head;\n    while (current) {\n        count++;\n        current = current.next;\n    }\n    \n    const middleIndex = Math.floor(count / 2);\n    current = head;\n    for (let i = 0; i < middleIndex; i++) {\n        current = current.next;\n    }\n    return current;\n}",
                "complexity": "Time: O(N), Space: O(1)",
                "example": "Input: [1]\nOutput: Nodo con valor 1"
            }
        ]
    },
    {
        "id": "squares-of-a-sorted-array",
        "title": "977. Squares of a Sorted Array",
        "difficulty": "Easy",
        "description": "Dado un array de enteros `nums` ordenado en orden no decreciente, devuelve un array de los cuadrados de cada número, también ordenado en orden no decreciente.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Two Pointers desde los Extremos (Óptima)",
                "explanation": "La solución más eficiente. Dado que el array original está ordenado, los valores más grandes al cuadrado estarán en los extremos (los números negativos más grandes o los positivos más grandes). Usamos dos punteros, `left` al inicio y `right` al final. Comparamos el valor absoluto de los números en `left` y `right`, colocamos el cuadrado del más grande al final de un nuevo array de resultados y movemos el puntero correspondiente.",
                "code_snippet": "function sortedSquares(nums) {\n    const n = nums.length;\n    const result = new Array(n);\n    let left = 0, right = n - 1;\n\n    for (let i = n - 1; i >= 0; i--) {\n        if (Math.abs(nums[left]) > Math.abs(nums[right])) {\n            result[i] = nums[left] * nums[left];\n            left++;\n        } else {\n            result[i] = nums[right] * nums[right];\n            right--;\n        }\n    }\n    return result;\n}",
                "complexity": "Time: O(N), Space: O(N) [para el resultado]",
                "example": "Input: nums = [-4,-1,0,3,10]\nOutput: [0,1,9,16,100]"
            },
            {
                "id": 2,
                "title": "Solución 2: Mapear y Ordenar (Naive)",
                "explanation": "La solución más simple y directa. Primero, creamos un nuevo array donde cada elemento es el cuadrado del elemento correspondiente en el array de entrada. Luego, simplemente ordenamos este nuevo array. Aunque es fácil de escribir, la ordenación lo hace menos eficiente que el enfoque de dos punteros.",
                "code_snippet": "function sortedSquares(nums) {\n    const squared = nums.map(num => num * num);\n    squared.sort((a, b) => a - b);\n    return squared;\n}",
                "complexity": "Time: O(N log N), Space: O(N)",
                "example": "Input: nums = [-7,-3,2,3,11]\nOutput: [4,9,9,49,121]"
            },
            {
                "id": 3,
                "title": "Solución 3: Separar y Fusionar",
                "explanation": "Un enfoque que sigue siendo O(N) pero conceptualmente diferente. Primero, encontramos el punto donde los números cambian de negativo a no negativo. Esto nos da dos sub-arrays 'virtuales': los negativos (que al cuadrado están ordenados de forma descendente) y los positivos (que al cuadrado están ordenados de forma ascendente). Luego, fusionamos estas dos listas ordenadas en un solo array resultado.",
                "code_snippet": "function sortedSquares(nums) {\n    const n = nums.length;\n    const result = [];\n    let right = 0;\n    while (right < n && nums[right] < 0) {\n        right++;\n    }\n    let left = right - 1;\n\n    while (left >= 0 && right < n) {\n        if (nums[left] * nums[left] < nums[right] * nums[right]) {\n            result.push(nums[left] * nums[left]);\n            left--;\n        } else {\n            result.push(nums[right] * nums[right]);\n            right++;\n        }\n    }\n    while (left >= 0) result.push(nums[left] * nums[left--]);\n    while (right < n) result.push(nums[right] * nums[right++]);\n    return result;\n}",
                "complexity": "Time: O(N), Space: O(N)",
                "example": "Input: nums = [-4,-1,0,3,10]\nOutput: [0,1,9,16,100]"
            }
        ]
    },
    {
        "id": "backspace-string-compare",
        "title": "844. Backspace String Compare",
        "difficulty": "Easy",
        "description": "Dadas dos cadenas `s` y `t`, devuelve `true` si son iguales cuando ambas se escriben en editores de texto vacíos. El carácter '#' significa un carácter de retroceso (backspace).",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Construir las Cadenas Finales",
                "explanation": "El enfoque más intuitivo. Creamos una función auxiliar que procesa una cadena y devuelve el resultado final después de aplicar los retrocesos. Esta función puede usar una pila o simplemente construir un nuevo array/cadena: si el carácter no es '#', lo añadimos; si es '#', eliminamos el último carácter. Luego, llamamos a esta función para `s` y `t` y comparamos los resultados.",
                "code_snippet": "function backspaceCompare(s, t) {\n    function build(str) {\n        const result = [];\n        for (const char of str) {\n            if (char !== '#') {\n                result.push(char);\n            } else if (result.length > 0) {\n                result.pop();\n            }\n        }\n        return result.join('');\n    }\n    return build(s) === build(t);\n}",
                "complexity": "Time: O(N + M), Space: O(N + M)",
                "example": "Input: s = \"ab#c\", t = \"ad#c\"\nOutput: true"
            },
            {
                "id": 2,
                "title": "Solución 2: Two Pointers desde el Final (Óptima)",
                "explanation": "La solución eficiente en espacio. Usamos dos punteros, uno para `s` y otro para `t`, comenzando desde el final. Recorremos hacia atrás. Si encontramos un '#', contamos cuántos retrocesos seguidos hay y saltamos esa cantidad de caracteres. Después de saltar los retrocesos, comparamos los caracteres válidos. Si no coinciden, o si un puntero llega al final antes que el otro, las cadenas son diferentes.",
                "code_snippet": "function backspaceCompare(s, t) {\n    let i = s.length - 1, j = t.length - 1;\n    let skipS = 0, skipT = 0;\n\n    while (i >= 0 || j >= 0) {\n        while (i >= 0) {\n            if (s[i] === '#') { skipS++; i--; }\n            else if (skipS > 0) { skipS--; i--; }\n            else break;\n        }\n        while (j >= 0) {\n            if (t[j] === '#') { skipT++; j--; }\n            else if (skipT > 0) { skipT--; j--; }\n            else break;\n        }\n\n        if (i >= 0 && j >= 0 && s[i] !== t[j]) return false;\n        if ((i >= 0) !== (j >= 0)) return false;\n\n        i--; j--;\n    }\n    return true;\n}",
                "complexity": "Time: O(N + M), Space: O(1)",
                "example": "Input: s = \"a##c\", t = \"#a#c\"\nOutput: true"
            },
            {
                "id": 3,
                "title": "Solución 3: Usando Stacks Explícitos",
                "explanation": "Esta solución es una implementación directa de la lógica de 'construir cadenas' usando una estructura de datos de pila. Creamos dos pilas. Recorremos `s` y `t` por separado. Por cada carácter, si no es '#', lo empujamos a su pila correspondiente. Si es '#', hacemos pop si la pila no está vacía. Finalmente, comparamos si las pilas son iguales (primero por tamaño, luego elemento por elemento).",
                "code_snippet": "function backspaceCompare(s, t) {\n    const process = (str) => {\n        const stack = [];\n        for (const char of str) {\n            if (char === '#') {\n                stack.pop();\n            } else {\n                stack.push(char);\n            }\n        }\n        return stack;\n    };\n    const stackS = process(s);\n    const stackT = process(t);\n    if (stackS.length !== stackT.length) return false;\n    for (let i = 0; i < stackS.length; i++) {\n        if (stackS[i] !== stackT[i]) return false;\n    }\n    return true;\n}",
                "complexity": "Time: O(N + M), Space: O(N + M)",
                "example": "Input: s = \"a#c\", t = \"b\"\nOutput: false"
            }
        ]
    },
    {
        "id": "diameter-of-binary-tree",
        "title": "543. Diameter of Binary Tree",
        "difficulty": "Easy",
        "description": "Dado el `root` de un árbol binario, devuelve la longitud del diámetro del árbol. El diámetro de un árbol binario es la longitud del camino más largo entre dos nodos cualesquiera en un árbol. Este camino puede o no pasar por la raíz.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: DFS con Variable Global/Externa",
                "explanation": "El enfoque más común y eficiente. El diámetro de un árbol en un nodo `n` es la suma de la altura de su subárbol izquierdo y la altura de su subárbol derecho. Usamos una función DFS que calcula la altura de un subárbol. Dentro de esta función, calculamos el diámetro que pasa por el nodo actual y actualizamos una variable de diámetro máximo si es necesario. La función devuelve la altura para que el nodo padre pueda usarla.",
                "code_snippet": "function diameterOfBinaryTree(root) {\n    let maxDiameter = 0;\n\n    function height(node) {\n        if (!node) return 0;\n\n        const leftHeight = height(node.left);\n        const rightHeight = height(node.right);\n\n        // Actualizar el diámetro máximo encontrado hasta ahora\n        maxDiameter = Math.max(maxDiameter, leftHeight + rightHeight);\n\n        // Devolver la altura de este subárbol\n        return 1 + Math.max(leftHeight, rightHeight);\n    }\n\n    height(root);\n    return maxDiameter;\n}",
                "complexity": "Time: O(N), Space: O(H) [Altura del árbol]",
                "example": "Input: root = [1,2,3,4,5]\nOutput: 3 (camino 4->2->1->3)"
            },
            {
                "id": 2,
                "title": "Solución 2: Bruta Fuerza (O(N^2))",
                "explanation": "Un enfoque ineficiente pero conceptualmente simple. Para cada nodo en el árbol, lo consideramos como el punto de inflexión del camino más largo. Calculamos la altura de su subárbol izquierdo y la altura de su subárbol derecho por separado. La suma de estas dos alturas es la longitud del camino más largo que pasa por ese nodo. Repetimos esto para todos los nodos y nos quedamos con el máximo. Esto implica recalcular alturas muchas veces.",
                "code_snippet": "function diameterOfBinaryTree(root) {\n    if (!root) return 0;\n\n    function height(node) {\n        if (!node) return 0;\n        return 1 + Math.max(height(node.left), height(node.right));\n    }\n\n    // Diámetro en la raíz actual\n    const rootDiameter = height(root.left) + height(root.right);\n    \n    // Diámetro en los subárboles\n    const leftDiameter = diameterOfBinaryTree(root.left);\n    const rightDiameter = diameterOfBinaryTree(root.right);\n\n    return Math.max(rootDiameter, leftDiameter, rightDiameter);\n}",
                "complexity": "Time: O(N^2), Space: O(H)",
                "example": "Input: root = [1,2]\nOutput: 1"
            },
            {
                "id": 3,
                "title": "Solución 3: DFS devolviendo un Par",
                "explanation": "Una variación de la solución óptima que evita el uso de una variable externa, promoviendo un estilo de programación más funcional. La función DFS devuelve un par de valores: `[altura, diámetro]`. Para un nodo dado, calcula recursivamente los pares para sus hijos. La nueva altura es `1 + max(altura_izq, altura_der)`. El nuevo diámetro es el máximo entre el `diámetro_izq`, `diámetro_der` y `altura_izq + altura_der`.",
                "code_snippet": "function diameterOfBinaryTree(root) {\n    function dfs(node) {\n        if (!node) return [-1, 0]; // [altura, diámetro]\n\n        const [leftHeight, leftDiameter] = dfs(node.left);\n        const [rightHeight, rightDiameter] = dfs(node.right);\n\n        const currentHeight = 1 + Math.max(leftHeight, rightHeight);\n        const currentDiameter = leftHeight + rightHeight + 2;\n        const maxSubtreeDiameter = Math.max(leftDiameter, rightDiameter);\n\n        return [currentHeight, Math.max(currentDiameter, maxSubtreeDiameter)];\n    }\n\n    return dfs(root)[1];\n}",
                "complexity": "Time: O(N), Space: O(H)",
                "example": "Input: root = [4,-7,-3,null,null,-9,-3,9,-7,-4,null,6,null,-6,-6,null,null,0,6,5,null,9,null,null,-1,-4,null,null,null,-2]\nOutput: 8"
            }
        ]
    },
    {
        "id": "maximum-depth-of-n-ary-tree",
        "title": "559. Maximum Depth of N-ary Tree",
        "difficulty": "Easy",
        "description": "Dado un árbol N-ario, encuentra su profundidad máxima. La profundidad máxima es el número de nodos a lo largo del camino más largo desde el nodo raíz hasta el nodo hoja más lejano.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Recursiva (DFS)",
                "explanation": "El enfoque más natural y elegante para los árboles. Para un nodo dado, su profundidad es 1 (el nodo mismo) más la profundidad máxima de todos sus hijos. La función calcula la profundidad de cada hijo recursivamente y devuelve 1 más el máximo de estas profundidades. El caso base es un nodo nulo, cuya profundidad es 0.",
                "code_snippet": "function maxDepth(root) {\n    if (!root) return 0;\n    \n    let maxChildDepth = 0;\n    for (const child of root.children) {\n        maxChildDepth = Math.max(maxChildDepth, maxDepth(child));\n    }\n    \n    return 1 + maxChildDepth;\n}",
                "complexity": "Time: O(N), Space: O(H) [Altura del árbol]",
                "example": "Input: root = [1,null,3,2,4,null,5,6]\nOutput: 3"
            },
            {
                "id": 2,
                "title": "Solución 2: Iterativa con Cola (BFS)",
                "explanation": "Podemos resolver esto usando un recorrido por niveles (BFS), que es ideal para encontrar la profundidad. Usamos una cola y un contador de niveles. En cada iteración del bucle principal, procesamos todos los nodos del nivel actual, añadiendo a todos sus hijos a la cola. Después de procesar un nivel completo, incrementamos el contador de profundidad.",
                "code_snippet": "function maxDepth(root) {\n    if (!root) return 0;\n\n    const queue = [root];\n    let depth = 0;\n\n    while (queue.length > 0) {\n        const levelSize = queue.length;\n        for (let i = 0; i < levelSize; i++) {\n            const node = queue.shift();\n            for (const child of node.children) {\n                queue.push(child);\n            }\n        }\n        depth++;\n    }\n    return depth;\n}",
                "complexity": "Time: O(N), Space: O(W) [Ancho máximo del árbol]",
                "example": "Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: 5"
            },
            {
                "id": 3,
                "title": "Solución 3: Iterativa con Pila (DFS)",
                "explanation": "Simulamos la recursión DFS usando una pila explícita. La pila almacenará pares de `[nodo, profundidad_actual]`. Empezamos empujando la raíz con profundidad 1. En un bucle, extraemos un par, actualizamos la profundidad máxima global y luego empujamos a todos sus hijos a la pila con una profundidad incrementada.",
                "code_snippet": "function maxDepth(root) {\n    if (!root) return 0;\n    const stack = [[root, 1]];\n    let max = 0;\n\n    while (stack.length > 0) {\n        const [node, depth] = stack.pop();\n        max = Math.max(max, depth);\n\n        for (const child of node.children) {\n            stack.push([child, depth + 1]);\n        }\n    }\n    return max;\n}",
                "complexity": "Time: O(N), Space: O(H)",
                "example": "Input: root = []\nOutput: 0"
            }
        ]
    },
    {
        "id": "find-all-numbers-disappeared-in-an-array",
        "title": "448. Find All Numbers Disappeared in an Array",
        "difficulty": "Easy",
        "description": "Dado un array `nums` de `n` enteros donde `nums[i]` está en el rango `[1, n]`, devuelve un array de todos los enteros en el rango `[1, n]` que no aparecen en `nums`.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Marcado In-Place (Óptima)",
                "explanation": "La solución más ingeniosa que utiliza espacio O(1). La idea es usar el propio array de entrada para marcar los números que hemos visto. Recorremos el array. Para cada número `num`, vamos al índice `abs(num) - 1` y marcamos el valor en esa posición como negativo. Después de la primera pasada, recorremos el array de nuevo. Si `nums[i]` es positivo, significa que el número `i + 1` nunca fue visto, por lo que lo añadimos a nuestro resultado.",
                "code_snippet": "function findDisappearedNumbers(nums) {\n    for (const num of nums) {\n        const index = Math.abs(num) - 1;\n        if (nums[index] > 0) {\n            nums[index] = -nums[index];\n        }\n    }\n\n    const result = [];\n    for (let i = 0; i < nums.length; i++) {\n        if (nums[i] > 0) {\n            result.push(i + 1);\n        }\n    }\n    return result;\n}",
                "complexity": "Time: O(N), Space: O(1) [sin contar el array de salida]",
                "example": "Input: nums = [4,3,2,7,8,2,3,1]\nOutput: [5,6]"
            },
            {
                "id": 2,
                "title": "Solución 2: Hash Set",
                "explanation": "Un enfoque simple y claro. Primero, creamos un `Set` con todos los números del array `nums` para tener búsquedas rápidas en O(1). Luego, iteramos desde 1 hasta `n`. Para cada número `i` en este rango, comprobamos si está en el `Set`. Si no lo está, lo añadimos a nuestro array de resultados.",
                "code_snippet": "function findDisappearedNumbers(nums) {\n    const seen = new Set(nums);\n    const result = [];\n    const n = nums.length;\n\n    for (let i = 1; i <= n; i++) {\n        if (!seen.has(i)) {\n            result.push(i);\n        }\n    }\n    return result;\n}",
                "complexity": "Time: O(N), Space: O(N)",
                "example": "Input: nums = [1,1]\nOutput: [2]"
            },
            {
                "id": 3,
                "title": "Solución 3: Ordenación Cíclica (Cyclic Sort)",
                "explanation": "Este patrón es útil cuando los números están en un rango `[1, n]`. La idea es colocar cada número en su posición correcta. Es decir, el número `x` debería estar en el índice `x - 1`. Recorremos el array, y para cada número `nums[i]`, mientras no esté en su lugar correcto (`nums[i] !== i + 1`) y no sea un duplicado del número que ya está en su lugar correcto, lo intercambiamos. Después de ordenar, una segunda pasada nos permite encontrar fácilmente los números faltantes.",
                "code_snippet": "function findDisappearedNumbers(nums) {\n    let i = 0;\n    while (i < nums.length) {\n        const correctIndex = nums[i] - 1;\n        if (nums[i] !== nums[correctIndex]) {\n            [nums[i], nums[correctIndex]] = [nums[correctIndex], nums[i]];\n        } else {\n            i++;\n        }\n    }\n    const result = [];\n    for (i = 0; i < nums.length; i++) {\n        if (nums[i] !== i + 1) {\n            result.push(i + 1);\n        }\n    }\n    return result;\n}",
                "complexity": "Time: O(N), Space: O(1) [sin contar el array de salida]",
                "example": "Input: nums = [4,3,2,7,8,2,3,1]\nOutput: [5,6]"
            }
        ]
    },
    {
        "id": "reverse-vowels-of-a-string",
        "title": "345. Reverse Vowels of a String",
        "difficulty": "Easy",
        "description": "Dada una cadena `s`, invierte solo todas las vocales de la cadena y devuélvela. Las vocales son 'a', 'e', 'i', 'o', 'u', y pueden aparecer tanto en minúsculas como en mayúsculas.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Two Pointers",
                "explanation": "El enfoque más eficiente. Convertimos la cadena en un array de caracteres para poder modificarla. Usamos dos punteros, `left` al inicio y `right` al final. Avanzamos `left` hasta que encuentre una vocal. Retrocedemos `right` hasta que encuentre una vocal. Una vez que ambos han encontrado una vocal, las intercambiamos. Continuamos hasta que `left` cruce a `right`.",
                "code_snippet": "function reverseVowels(s) {\n    const vowels = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);\n    const arr = s.split('');\n    let left = 0, right = arr.length - 1;\n\n    while (left < right) {\n        while (left < right && !vowels.has(arr[left])) {\n            left++;\n        }\n        while (left < right && !vowels.has(arr[right])) {\n            right--;\n        }\n        if (left < right) {\n            [arr[left], arr[right]] = [arr[right], arr[left]];\n            left++;\n            right--;\n        }\n    }\n    return arr.join('');\n}",
                "complexity": "Time: O(N), Space: O(N) [para el array de caracteres]",
                "example": "Input: s = \"hello\"\nOutput: \"holle\""
            },
            {
                "id": 2,
                "title": "Solución 2: Recolectar e Invertir",
                "explanation": "Un enfoque de dos pasadas. En la primera pasada, recorremos la cadena y recolectamos todas las vocales en un array (o cadena). En la segunda pasada, recorremos la cadena original de nuevo. Si un carácter no es una vocal, lo añadimos al resultado tal cual. Si es una vocal, añadimos la última vocal del array de vocales recolectadas (que hemos invertido o que leemos desde el final).",
                "code_snippet": "function reverseVowels(s) {\n    const vowels = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);\n    const foundVowels = [];\n    for (const char of s) {\n        if (vowels.has(char)) {\n            foundVowels.push(char);\n        }\n    }\n    let result = \"\";\n    for (const char of s) {\n        if (vowels.has(char)) {\n            result += foundVowels.pop();\n        } else {\n            result += char;\n        }\n    }\n    return result;\n}",
                "complexity": "Time: O(N), Space: O(K) [donde K es el número de vocales]",
                "example": "Input: s = \"leetcode\"\nOutput: \"leotcede\""
            },
            {
                "id": 3,
                "title": "Solución 3: Usando Expresiones Regulares",
                "explanation": "Un enfoque conciso que utiliza expresiones regulares. Primero, usamos `match` con una expresión regular `/[aeiou]/gi` para encontrar todas las vocales y almacenarlas. Luego, usamos `replace` con la misma expresión regular. La función de reemplazo se llamará por cada vocal encontrada en orden, y simplemente devolvemos la última vocal del array que extrajimos, haciendo pop en cada llamada.",
                "code_snippet": "function reverseVowels(s) {\n    const vowels = s.match(/[aeiou]/gi);\n    if (!vowels) return s;\n    return s.replace(/[aeiou]/gi, () => vowels.pop());\n}",
                "complexity": "Time: Depende del motor de regex, generalmente O(N). Space: O(K)",
                "example": "Input: s = \"aA\"\nOutput: \"Aa\""
            }
        ]
    },
    {
        "id": "range-sum-query-immutable",
        "title": "303. Range Sum Query - Immutable",
        "difficulty": "Easy",
        "description": "Dado un array de enteros `nums`, maneja múltiples consultas del siguiente tipo: calcula la suma de los elementos de `nums` entre los índices `left` y `right` inclusive, donde `left <= right`. Implementa la clase `NumArray`.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Suma de Prefijos (Caching)",
                "explanation": "La solución óptima para múltiples consultas. En el constructor, precalculamos un array de 'suma de prefijos' (`prefixSum`). `prefixSum[i]` almacena la suma de todos los elementos desde el índice 0 hasta `i-1`. Entonces, la suma de un rango `[left, right]` se puede calcular en tiempo O(1) como `prefixSum[right + 1] - prefixSum[left]`. Esto traslada el costo computacional a la inicialización.",
                "code_snippet": "class NumArray {\n    constructor(nums) {\n        this.prefixSum = new Array(nums.length + 1).fill(0);\n        for (let i = 0; i < nums.length; i++) {\n            this.prefixSum[i + 1] = this.prefixSum[i] + nums[i];\n        }\n    }\n\n    sumRange(left, right) {\n        return this.prefixSum[right + 1] - this.prefixSum[left];\n    }\n}",
                "complexity": "Constructor: O(N), sumRange: O(1). Space: O(N)",
                "example": "NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nsumRange(0, 2); // return 1\nsumRange(2, 5); // return -1"
            },
            {
                "id": 2,
                "title": "Solución 2: Fuerza Bruta",
                "explanation": "La solución más simple. No hacemos ningún pre-cálculo en el constructor. Cada vez que se llama a `sumRange(left, right)`, simplemente iteramos desde `left` hasta `right` en el array original y sumamos los elementos. Esto es eficiente si solo se realizan unas pocas consultas, pero ineficiente para muchas.",
                "code_snippet": "class NumArray {\n    constructor(nums) {\n        this.nums = nums;\n    }\n\n    sumRange(left, right) {\n        let sum = 0;\n        for (let i = left; i <= right; i++) {\n            sum += this.nums[i];\n        }\n        return sum;\n    }\n}",
                "complexity": "Constructor: O(1), sumRange: O(N). Space: O(1)",
                "example": "NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nsumRange(0, 5); // return -3"
            },
            {
                "id": 3,
                "title": "Solución 3: Caching de Consultas (Memoización)",
                "explanation": "Un enfoque alternativo de caching. En lugar de precalcular todas las sumas de prefijos, almacenamos en caché los resultados de las consultas `sumRange` a medida que se realizan. Usamos un mapa donde la clave puede ser una cadena como `'left-right'`. Si la consulta ya se ha realizado, devolvemos el valor almacenado. Si no, la calculamos (con fuerza bruta), la almacenamos y la devolvemos. Solo es útil si se repiten las mismas consultas exactas.",
                "code_snippet": "class NumArray {\n    constructor(nums) {\n        this.nums = nums;\n        this.cache = new Map();\n    }\n\n    sumRange(left, right) {\n        const key = `${left}-${right}`;\n        if (this.cache.has(key)) {\n            return this.cache.get(key);\n        }\n\n        let sum = 0;\n        for (let i = left; i <= right; i++) {\n            sum += this.nums[i];\n        }\n\n        this.cache.set(key, sum);\n        return sum;\n    }\n}",
                "complexity": "Constructor: O(1), sumRange: O(N) la primera vez, O(1) en llamadas subsecuentes para el mismo rango. Space: O(Q) [donde Q es el número de consultas únicas]",
                "example": "NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nsumRange(0, 2); // Calcula y devuelve 1\nsumRange(0, 2); // Devuelve 1 desde el caché"
            }
        ]
    },
    {
        "id": "word-pattern",
        "title": "290. Word Pattern",
        "difficulty": "Easy",
        "description": "Dada un `pattern` y una cadena `s`, determina si `s` sigue el mismo patrón. Aquí, 'seguir' significa una correspondencia completa, de modo que hay una biyección entre una letra en `pattern` y una palabra no vacía en `s`.",
        "solutions": [
            {
                "id": 1,
                "title": "Solución 1: Dos Mapas (Hash Maps)",
                "explanation": "El enfoque más robusto. Para asegurar una biyección (una correspondencia uno a uno), necesitamos dos mapas. Un mapa (`charToWord`) mapea caracteres del patrón a palabras, y otro (`wordToChar`) mapea palabras a caracteres. Al iterar, si un carácter ya está en el mapa, verificamos que la palabra actual coincida con su mapeo. Si no está, verificamos que la palabra actual no haya sido mapeada por otro carácter. Si ambas comprobaciones pasan, creamos el nuevo mapeo en ambos mapas.",
                "code_snippet": "function wordPattern(pattern, s) {\n    const words = s.split(' ');\n    if (pattern.length !== words.length) return false;\n\n    const charToWord = new Map();\n    const wordToChar = new Map();\n\n    for (let i = 0; i < pattern.length; i++) {\n        const char = pattern[i];\n        const word = words[i];\n\n        if (charToWord.has(char)) {\n            if (charToWord.get(char) !== word) return false;\n        } else {\n            if (wordToChar.has(word)) return false;\n            charToWord.set(char, word);\n            wordToChar.set(word, char);\n        }\n    }\n    return true;\n}",
                "complexity": "Time: O(N + M), Space: O(C + W) [C=caracteres únicos, W=palabras únicas]",
                "example": "Input: pattern = \"abba\", s = \"dog cat cat dog\"\nOutput: true"
            },
            {
                "id": 2,
                "title": "Solución 2: Un Mapa y un Set",
                "explanation": "Una ligera optimización de la primera solución. En lugar de un segundo mapa (`wordToChar`), podemos usar un `Set` para rastrear las palabras que ya han sido utilizadas en un mapeo. El `Set` simplemente nos dice si una palabra ya ha sido 'tomada' por otro carácter del patrón, asegurando la parte 'uno a uno' de la biyección.",
                "code_snippet": "function wordPattern(pattern, s) {\n    const words = s.split(' ');\n    if (pattern.length !== words.length) return false;\n\n    const map = new Map();\n    const usedWords = new Set();\n\n    for (let i = 0; i < pattern.length; i++) {\n        const char = pattern[i];\n        const word = words[i];\n\n        if (map.has(char)) {\n            if (map.get(char) !== word) return false;\n        } else {\n            if (usedWords.has(word)) return false;\n            map.set(char, word);\n            usedWords.add(word);\n        }\n    }\n    return true;\n}",
                "complexity": "Time: O(N + M), Space: O(C + W)",
                "example": "Input: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false"
            },
            {
                "id": 3,
                "title": "Solución 3: Usando `indexOf`",
                "explanation": "Un truco ingenioso pero menos legible. La idea es que para cualquier índice `i`, la primera vez que vemos `pattern[i]` debe coincidir con la primera vez que vemos `words[i]`. Podemos verificar esto comparando `pattern.indexOf(pattern[i])` con `words.indexOf(words[i])` para cada `i`. Si estos índices no son iguales en algún punto, el patrón se rompe.",
                "code_snippet": "function wordPattern(pattern, s) {\n    const words = s.split(' ');\n    if (pattern.length !== words.length) return false;\n\n    for (let i = 0; i < pattern.length; i++) {\n        if (pattern.indexOf(pattern[i]) !== words.indexOf(words[i])) {\n            return false;\n        }\n    }\n    return true;\n}",
                "complexity": "Time: O(N * (N + M)), debido a las repetidas llamadas a `indexOf`. Space: O(M)",
                "example": "Input: pattern = \"abc\", s = \"dog cat dog\"\nOutput: false"
            }
        ]
    }
]